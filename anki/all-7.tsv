Prob: skyline<br>how to solve, complex	 <b>divide and conquer</b><br>similar to merge sort<br><br>- divide in <b>2 equal sets</b> (no order or sort)<br>- compute skyline for each<br>- <b>merge</b>: <b>iterate</b> on both<br><br>O(n log n)
Prob: count number of inversion i<j A(i)>A(j)	<b>divide and conquer</b>: within two halves + merge<br>= <b>modified merge sort</b><br><br>merge function sorts and returns inversion count<br><br>O(n log n)
Geo: closest pair with divide and conquer	split in two sets with <b>median</b> of x<br><br>compute min in each side<br>d = min of 2 mins<br><br>merge: get all points in <b>band (-d,+d)</b> and <b>sort with y</b><br><br>find <b>smallest pair in band</b>: not O(n^2) but O(n) since only <b>constant nb points</b> to check
Tree: Maximum path sum in a binary tree (or diameter)	recursive divide and conquer<br><br>rec functions return {maxCompletePath, maxIncompletePath}<br><br>O(n)<br><br>or use global variable
Prob: subarray sum closest to 0	build <b>prefix sum</b> array<br><b>sort</b> it<br><br>loop and find min consecutive difference<br><br>O(n log n)
Prob: maximum circular subarray sum	1. compute non-circular<br>2. compute circular: <b>careful</b><br><br>need to try all cutting points O(n)<br><br>or compute <b>minimum non-circular</b> and <b>complement</b><br><br>O(n)
DP: length of longest increasing subsequence	- O(n^2) bestLISEndingAtOffset[i]<br><br>- O(n log n) <b>active lists</b> (duplicate and extend)<br>or <b>tail array</b>: t[i] smallest tail of all increasing subsequences with length i+1<br><b>update cell or extend</b>
Prob: longest subarray with sum <= k	build <b>prefix sum array R</b><br>prob: for i, pick largest j s.t. R(j) <= R(i) + k<br><br><b>efficient frontier</b> array of R:<br>ignore decreasing values: build <b>staircase increasing</b> array<br><br>then: for each i, do <b>binary search</b> to find j<br><br>O(n log n)
Prob: largest rectangle under histogram	iterate on bars: find <b>largest rectangle to the left with this bar and height</b><br><br><b>efficient frontier:</b> keep only past building with <b>increasing height (stack)</b><br><br>O(n)
Prob: largest all-1s 2D subarray (or cross shape)	<b>precompute</b>: for each cell, <b>number of 1s</b> to the <b>left</b>, and <b>down</b><br><br>then: for each cell, find largest subarray <b>with this corner</b> (iterate on sizes)<br><br>O(n^2 m)
Prob:<br>Coin Game: coins in a row, pick one	<b>windowed DP</b><br><br>F(i,j) = max (coinChosen + whatIsLeftAfterOtherPlayer(=min))<br><br>F(from coin i to j) = max(. + min(), . + min())<br>O(n^2)
DS: countâ€“min sketch, def, use	probabilistic data structure: <b>frequency table of events</b> in a <b>stream</b> of data<br><br>same as <b>counting Bloom Filter</b><br><br><b>Table</b>: row=hash function, column: bucket (space of hash), entry: integer<br><br>ex: count views for many many videos
DS: HyperLogLog, def, use	<b>approximate count-distinct</b><br>hash stream entries and only record the <b>longest leading zero seq length</b><br><br>-> <b>estimate</b> the number of <b>distinct entries</b><br>Improve accuracy with buckets, removing outliers and averaging<br><br>Use in ApproxCountDistinct in DBs.
DS: tournament tree, def, use	complete binary tree<br>2 case: <b>winner</b>, <b>loser</b> tree<br><br>player=leaves<br>min/max winner/loser<br><br>apps: sorting, first-fit bin packing, k-way merge
Prob: Huffman coding	sort characters by frequency<br>merge two <b>least common</b> chars into one node (with sum frequency)<br>repeat<br><br>use <b>min-heap</b><br><br>O(n log n)
Prob: reflex<br>1. permutation<br>2. DAG<br>3. "top k" (2)<br>4. Geometric problem<br>5. Intervals (2)	1. cycles<br>2. topological sort<br>3. heap, k-selection<br>4. sweep line<br>5. sort by start or end, interval tree
Prob: reflex<br>1. linked list (2)<br>2. array range/subarray<br>3. search (2)<br>4. palindrome<br>5. 1D/2D problem	1. two pointers, reverse<br>2. prefix sum<br>3. sort before, k-selection<br>4. look at reverse string (LCS)<br>5. DP
Prob: reflex<br>1. get low complexity for conflicting ops	1. use multiple DS (reverse index)
DS: 6 example use of a heap	- priority queue<br>- min of streaming data<br>- k-way merge<br>- continous median<br>- sort when only k indices away<br>- heapsort
Trees: types of trees (8)	- binary or not<br>- BST (balanced or not)<br>- trie<br>- heap<br>- spanning (with a graph)<br>- tournament (win/lose min/max)<br>- Merkle<br>- prefix tree
Prob: set of equality and inequality constraints on a set of boolean variables, find if possible	build undirected graph with <b>equality</b> only<br>compute <b>connected components</b><br><br>for <b>each inequality</b>: check that they are in <b>different connected components</b>
Graph: 4 classes of problems in polynomial time	- shortest paths<br>- MST<br>- matching<br>- max flow
Prob: arbitrage between a set of exchangeable currencies	take log of rates<br>look for <b>negative weight cycle</b><br>alg: <b>Bellman-Ford</b> O(VE)
Prob: shortest path with a max delay constraint (edges have weight and delay)	<b>memoized DP</b><br>dp[destinationVertex,withDelay]<br><br>O(E maxDelay)
Prob: approximate TSP in 2D plane when distance is euclidian	satisfies <b>triangle inequality</b><br><br>build <b>MST</b> from graph<br><br>tour: <b>like in-order walk</b> on MST skipping already seen vertices<br><br>thanks to triangle ineq., approximation factor: <b>2</b>
Prob: approximate warehouse location problem (k warehouse for n cities), with euclidian distance	heuristic: one warehouse at a time<br><br>choose warehouse <b>farthest</b> from existing warehouses
SD: <b>synchronized</b> Java primitive	used to define a <b>critical section</b><br><br>only <b>one thread</b> can enter block of code<br><br>can be used on code blocks or methods
SD: thread model for a web server	use <b>thread pool</b><br><br><b>avoids overhead</b> when create/delete<br>caps <b>maxThreads</b><br><br>use <b>synchronized task queue</b>
SD: readers-writers problem (3 variations)	<b>multiple readers</b> at the same time<br>only <b>1 writer</b><br><br>1. readers preference (can starve writers)<br>2. writers preference (starve readers)<br>3. fairness
SD: Deadlock (def, example)	task waits forever for conditions that can not be met<br><br>tasks wait for other tasks<br><br>ex: 2 tasks with 2 resources with each 1 lock<br>dining philosophers
SD: dining philosophers problem, solutions (2)	round table, knife/fork<br><br>1. request <b>smaller index</b> resources first<br><br>or 2. add <b>arbitrator</b>
SD: producer-consumer problem, solution	fixed size buffer<br>ensure that don't read if empty, don't write if full<br><br>use <b>2 semaphores</b>: remainingSpace, currentItems
Prob: problem solving steps	<b>CEEBETT</b><br><b>C</b>larify<br><b>E</b>xample<br><b>E</b>dge cases<br><b>B</b>rute force<br><b>E</b>fficient solution<br><b>T</b>rade-offs<br><b>T</b>ests
ree: compress binary trees to canonical form	use <b>hashing</b> on nodes/subtrees<br><br>recursive
Tree: Check if a binary tree is <b>subtree</b> of another (2)	Naive O(n^2), <br><br>- O(n): <b>inorder and preorder</b> of subtree must be <b>substrings</b> of big tree<br><br>- O(n): <b>hashing</b> of subtrees
Geo: line through most points	H[line] = list of points<br><br>for each pair, add entry in H<br><br>tricky hash because floats<br>use rationals
Prob: find elements that appear more than k/n times	generalization of <b>voting</b><br><br><b>two passes</b><br>- keep <b>k</b> counters in <b>hash</b><br><br>purge hash table when needed<br><br>- second pass to check candidates
