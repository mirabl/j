Geo: line through most points	H[line] = list of points<br><br>for each pair, add entry in H<br><br>tricky hash because floats<br>use rationals
Prob: find elements that appear more than k/n times	generalization of <b>voting</b><br><br><b>two passes</b><br>- keep <b>k</b> counters in <b>hash</b><br><br>purge hash table when needed<br><br>- second pass to check candidates
Sort:<br>3 big sorts on large data<br>+ advantages	quicksort: <b>fast</b>, not stable unless storage, bad <b>worst case</b><br><br>mergesort: <b>stable</b>, <b>not in-place</b>, parallelizable, contiguous access<br><br>heapsort: <b>in-place, not stable</b>, <b>slower</b> than quicksort
Sort: which sort for:<br>1. general large integer array<br>2. small array<br>3. almost sorted<br>4. small range array<br>5. many duplicates<br>6. stability required	1. quicksort<br>2. insertion sort<br>3. depends on def. heap, heapsort, insertion sort<br>4. counting sort in array or BST<br>5. merge sort or decorate-sort (key, index)
Sort: sort without moving too many records (which might be expensive)	indirect sort:<br>1. sort secondary <b>array of indices</b><br><br>2. apply sort to array (move records)
SD: messaging system semantics	<b>at-least-once</b>: producer client retries when ack timeout or error<br><br><b>at-most-once</b>: no retries<br><br><b>exactly-once</b>: on Kafka, uses sequence numbers
BST: insert/delete	- insert: recursive like searching<br><br>- delete: replace by successor in right subtree<br>careful corner cases
BST: build from sorted linked list	avoid finding the middle over and over<br><br>have pointer in list<br><br>recursively create left subtree<br>move pointer and set root value<br><br>recursively create right<br><br>O(n)
Prob: from 3 sorted arrays, find i, j, k s.t. d(i,j,k)=max(|A(i)-B(j)|, ...) is minimum	<b>1 pointer in each</b><br><b>move 1</b> (min) at each step<br><br>like intersection of sorted arrays<br><br>record minimum<br><br>O(len A + len B + ..)
Prob: most visited pages, compute top-k by frequency:<br>-1. once at end<br>-2. any time streaming	1. hash map freq[s]<br>at end, do <b>k-selection</b> (quickselect, heap, 2k array) O(n)<br><br>2. hash map bstNodeForString[s] + <b>BST</b> with (count, s)<br><br>update by deleting/re-inserting in BST<br>end: top-k from BST
Prob: most visited pages in last W fixed seconds, query any time streaming	<b>3 structures</b>:<br><br>1. HashMap bstNodeForString[s]<br><br>2. BST: (count, s)<br><br>3. Queue Q of elements in current window<br><br>increase-decrease in BST when insert/remove from Q
Prob: Gaussian primes	primes with integer-complex numbers<br>sort by <b>modulus</b> to order them and put in BST<br><br>Eratosthene <b>sieve</b>
Prob: View from above (stacked segments of different color and height)	sort enter/exit list of segments<br>maintain <b>BST</b> (height, color)
BST: nodes have <b>size of their subtree</b> as a field<br>- find size of a <b>range</b> [a,b]<br>- how to <b>update</b> when insert/delete	count number of nodes <a: search a and <b>update count</b> if go <b>left</b> or <b>right</b><br>res: totalsize- "<a" - ">b"<br><br>update: change size along the search path of node to add/remove
Prob: given set of intervals, find all that <b>intersect a query interval</b><br>support insert/delete	use <b>Interval Tree</b><br><br>search for <b>one</b> intersecting interval<br>remove it<br>repeat
Prob: skyline<br>how to solve, complex	 <b>divide and conquer</b><br>similar to merge sort<br><br>- divide in <b>2 equal sets</b> (no order or sort)<br>- compute skyline for each<br>- <b>merge</b>: <b>iterate</b> on both<br><br>O(n log n)
Prob: count number of inversion i<j A(i)>A(j)	<b>divide and conquer</b>: within two halves + merge<br>= <b>modified merge sort</b><br><br>merge function sorts and returns inversion count<br><br>O(n log n)
Geo: closest pair<br>def, 2 algs	find the pair that is closest<br><br><b>sweep line</b>: O(n log n)<br><br><b>divide and conquer</b>: O(n log^2 n)
Geo: closest pair with divide and conquer	split in two sets with <b>median</b> of x<br><br>compute min in each side<br>d = min of 2 mins<br><br>merge: get all points in <b>band (-d,+d)</b> and <b>sort with y</b><br><br>find <b>smallest pair in band</b>: not O(n^2) but O(n) since only <b>constant nb points</b> to check
Tree: Maximum path sum in a binary tree (or diameter)	recursive divide and conquer<br><br>rec functions return {maxCompletePath, maxIncompletePath}<br><br>O(n)<br><br>or use global variable
Prob: subarray sum closest to 0	build <b>prefix sum</b> array<br><b>sort</b> it<br><br>loop and find min consecutive difference
Prob: maximum circulary subarray sum	1. compute non-circular<br>2. compute circular: <b>careful</b><br><br>need to try all cutting points O(n)<br><br>or compute <b>minimum non-circular</b> and <b>complement</b><br><br>O(n)
DP: length of longest increasing subsequence	- O(n^2) bestLISEndingAtOffset[i]<br><br>- O(n log n) <b>active lists</b> (duplicate and extend)<br>or <b>tail array</b>: t[i] smallest tail of all increasing subsequences with length i+1<br><b>update cell or extend</b>
Prob: longest subarray with sum <= k	build <b>prefix sum array R</b><br>prob: for i, pick largest j s.t. R(j) <= R(i) + k<br><br><b>efficient frontier</b> array of R:<br>ignore decreasing values: build <b>staircase increasing</b> array<br><br>then: for each i, do <b>binary search</b> to find j<br><br>O(n log n)
Prob: largest rectangle under histogram	iterate on bars: find <b>largest rectangle to the left with this bar and height</b><br><br><b>efficient frontier:</b> keep only past building with <b>increasing height (stack)</b><br><br>O(n)
Prob: largest all-1s 2D subarray (or cross shape)	precompute: for each cell, <b>number of 1s</b> to the <b>left</b>, and <b>down</b><br><br>then: for each cell, find largest subarray <b>with this corner</b> (iterate on sizes)<br><br>O(n^2 m)
Prob:<br>Coin Game: coins in a row, pick one	<b>windowed DP</b><br><br>F(i,j) = max (coinChosen + whatIsLeftAfterOtherPlayer(=min))<br><br>F(from coin i to j) = max(. + min(), . + min())<br>O(n^2)
DS: countâ€“min sketch, def, use	probabilistic data structure: <b>frequency table of events</b> in a <b>stream</b> of data<br><br>same as <b>counting Bloom Filter</b><br><br><b>Table</b>: row=hash function, column: bucket (space of hash), entry: integer<br><br>ex: count views for many many videos
DS: HyperLogLog, def, use	<b>approximate count-distinct</b><br>hash stream entries and only record the <b>longest leading zero seq length</b><br><br>-> <b>estimate</b> the number of <b>distinct entries</b><br>Improve accuracy with buckets, removing outliers and averaging<br><br>Use in ApproxCountDistinct in DBs.
DS: tournament tree, def, use	complete binary tree<br>2 case: <b>winner</b>, <b>loser</b> tree<br><br>player=leaves<br>min/max winner/loser<br><br>apps: sorting, first-fit bin packing, k-way merge
Prob: Huffman coding	sort characters by frequency<br>merge two <b>least common</b> chars into one node (with sum frequency)<br>repeat<br><br>use <b>min-heap</b><br><br>O(n log n)
Prob: reflex<br>1. permutation<br>2. DAG<br>3. "top k"<br>4. Geometric problem<br>5. Intervals	1. cycles<br>2. topological sort<br>3. heap<br>4. sweep line<br>5. sort by start or end
Prob: reflex<br>1. linked list (2)<br>2. array range<br>3. search<br>4. palindrome<br>5. 1D/2D problem	1. two pointers, reverse<br>2. prefix sum<br>3. sort before, k-selection<br>4. look at reverse string (LCS)<br>5. DP
Prob: reflex<br>1. get low complexity for conflicting ops	1. use multiple DS (reverse index)
DS: 6 example use of a heap	- priority queue<br>- min of streaming data<br>- k-way merge<br>- continous median<br>- sort when only k indices away<br>- heapsort
Tree: Serialize/Deserialize	<b>preorder and NULL marker</b><br><br>or: pre AND inorder<br>better: <br><br>Special case?<br>BST: pre or postorder<br>Complete: level order<br>Full: preorder with boolean for leaves
Array: Next Greater element in an array (2)	- from right to left, using a stack<br><br>- or left to right with stack, but map also<br><br>O(n)/O(n)
Trees: types of trees (7)	- binary or not<br>BST (balanced or not)<br>trie<br>heap<br>- spanning (with a graph)<br>- tournament (win/lose min/max)<br>Merkle