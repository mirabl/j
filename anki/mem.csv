compute depth of a binary tree;recursive 1 + max()
reverse a linked list;iterative
reverse array in place;swap elements, maybe middle 
cycle length of a linked list;2 pointers 
is a linked list a palindrome?;reverse second half, check (and restore)
find where 2 linked list merge;2 pointers 
remove a node from a linked list;careful cases
middle of a linked list;2 pointers
iterative in-order traversal of binary tree;stack and curnode pointer
determine if a string has only unique characters (with and without memory);use a set, or sort the string
hanoi Towers;x
implement a queue using two stacks;empty first stack into second stack
sort a stack;using a second stack, or recursively
is there a route between two nodes of a directed graph;careful with cycles
from sorted array, create BST with minimal height;take middle of array then recursive
find lowest common ancestor of two nodes in a binary tree;LCA has one node on each side
explain what the following code does: ((n & (n-1)) == 0);test if power of 2
compute subsets of a set;recursive, iterative
compute all permutations of a string;recursive
print valid n-parentheses;try a character, recurse if allowed
8 queens;x
find element in a sorted rotated array;double BS
find element in row-and-column-sorted matrix;start from NE corner
number of trailing zeroes in a factorial;powers of 2, 5
merge k sorted arrays;heap
max number of intersecting intervals;x
is subsequence;iterate 
rotate image by 90 degrees;ring by ring, or reverse up to down (r2l) and transpose
insertion sort;insert A[i] in A[0]...A[i-1]
selection sort;select min put it at A[i=0], i++
bubble sort;swap pairs to put max at i=end of array, i--
merge sort;merge sorted subarrays with auxiliary array (allocate once)
quicksort;(randomize first), select pivot, partition, sort left and right partition
stack in C++;#include <stack>, push(), pop(), top()
queue in C++;#include <queue>, push(), pop(), front()
insertion in linked list tip;use dummy first node
vector in C++ access/remove last element;back()/pop_back()
two ways to do BFS level order of tree;with NULL marker, or empty queue at each step
2sum: Given an array of integers, return indices of the two numbers such that they add up to a specific target.;same element twice? Use hash table O(n)|O(n), sort+two pointers O(n log n)|O(1), sort+BS O(n log n)|O(1)
Longest Substring Without Repeating Characters;left and right pointers, hash set for characters in the substring, move either left or right O(n)|O(n) // traverse left to right, maintaining longest valid substring ending at this position, use map<char,position> to know where current character appeared last O(n)|O(n)
Longest Palindromic Substring;for each position, find longest even and odd length substring with this center O(n^2)|O(1) // DP bottom-up with length-0 length-1 -2 ... substrings O(n^2)|O(1) // O(n) difficult algorithm exists
Container With Most Water;two pointers, from start and end, reduce width and stop only when height increases, O(n)|O(1)
3Sum  Find all unique triplets in the array which gives the sum of zero;sort, loop for first element and then 2sum sweep, avoid duplicates by avoiding duplicate first element O(n^2)|O(1)
substring search;naive O(n*m) // robin-karp rolling hash O(n + m) // advanced O(n)
next permutation;?
combination sum: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T., same number can be repeated;backtracking (or DP)
maximum subarray sum;one pass, at each position either extend or start new subarray O(n)|O(1)
merge intervals;sort by start, one pass O(nlog n)|O(n)
index in permutation sequence;
Find the smallest window in a string containing all characters of another string;sliding window O(n)|O(n)
gray code;formula, recursion?
last-M-th element of a linked list;2 pointers, one M ahead
implement stack with O(1) min;push (x, min) when pushing x, or use second stack
Breadth First Traversal or BFS for a Graph;O(V + E)/O(V)
Depth First Traversal or DFS for a Graph;O(V + E)/O(V)
 Shortest Path from source to all vertices **Dijkstra** ;Time: O(V^2). Better complexity with Fibonacci heap.
Shortest Path from every vertex to every other vertex **Floyd Warshall**;O(V^3)/O(V^2)
To detect cycle in a Graph **Union Find** (method1);O(EV) if naive O(n) implementation of union() and find()
Minimum Spanning tree **Prim** ;greedy vertices: add new vertex of minimum distance to partial tree. O(V^2), can be reduced with binary heap.
Minimum Spanning tree **Kruskal** ;sort edges by weight, (take min edge, check if it introduces a cycle in the partial tree, discard or add). Cycle detection with union-find. O(E log V) = O(E log E)
Topological Sort; on DAG. DFS with stack: push to stack after calling DFS on adjacent vertices (so they are on the stack below). O(V + E)
Boggle (Find all possible words in a board of characters);DFS from every start cell, mark visited cells. Complexity? Better solution with Tree.
Bridges in a Graph;Naive: remove edge, see if graph is still connected: O(E (V + E)). Better algorithm based on DFS O(V + E) exists.
Detect beginning of a cycle;method1: count cycle length, count first segment length. method2: smarter, TODO. O(n)
Sort a linked list;use merge sort
Select random node from linked list;method1: count nodes first. method2:reservoir sampling O(n) one pass.
