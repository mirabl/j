Max number of intersecting intervals;sort events: enter and exist of intervals. O(n log n)|O(n) aux
2sum: Given an array of integers, return indices of the two numbers such that they add up to a specific target.;same element twice? Use hash table O(n)|O(n), sort+two pointers O(n log n)|O(1), sort+BS O(n log n)|O(1)
Longest Substring Without Repeating Characters;left and right pointers, hash set for characters in the substring, move either left or right O(n)|O(n) // traverse left to right, maintaining longest valid substring ending at this position, use map<char,position> to know where current character appeared last O(n)|O(n)
Longest Palindromic Substring;for each position, find longest even and odd length substring with this center O(n^2)|O(1) // DP bottom-up with length-0 length-1 -2 ... substrings O(n^2)|O(1) // O(n) difficult algorithm exists
Container With Most Water;two pointers, from start and end, reduce width and stop only when height increases, O(n)|O(1)
3Sum  Find all unique triplets in the array which gives the sum of zero;sort, loop for first element and then 2sum sweep, avoid duplicates by avoiding duplicate first element O(n^2)|O(1)
substring search;naive O(n*m) // robin-karp rolling hash O(n + m) // advanced O(n)
next permutation;?
combination sum: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T., same number can be repeated;backtracking (or DP)
maximum subarray sum;one pass, at each position either extend or start new subarray O(n)|O(1)
Merge intervals;sort by start, one pass O(nlog n)|O(n)
Complexity of Breadth First Traversal or BFS for a Graph;O(V + E) if adjacency list, O(V^2) if adjacency matrix/O(V)
Complexity of Depth First Traversal or DFS for a Graph;time: O(V + E) if adjacency list, O(V^2) if adjacency matrix/O(V) 
Shortest Path from source to all vertices **Dijkstra** ;Time: O(V^2). Better complexity with Fibonacci heap.
Shortest Path from every vertex to every other vertex **Floyd Warshall**;O(V^3)/O(V^2)
To detect cycle in a Graph **Union Find** (method1);O(EV) if naive O(n) implementation of union() and find()
Minimum Spanning tree **Prim**: algorithm and complexity;greedy vertices: add new vertex of minimum distance to partial tree. O(V^2), can be reduced with binary heap.
Minimum Spanning tree **Kruskal**: algorithm and complexity;sort edges by weight, (take min edge, check if it introduces a cycle in the partial tree, discard or add). Cycle detection with union-find. O(E log V) = O(E log E)
Topological Sort; on DAG. DFS with stack: push to stack after calling DFS on adjacent vertices (so they are on the stack below). O(V + E)
Bridges in a Graph;Naive: remove edge, see if graph is still connected: O(E (V + E)). Better algorithm based on DFS O(V + E) exists.
Detect beginning of a cycle;method1: count cycle length, count first segment length. method2: smarter, TODO. O(n)
Longest Common Subsequence;DP O(nm)
Longest Increasing Subsequence;DP O(n^2). also possible in O(n log n) with active lists and binary search
Minimum difference partition;DP CanMakeSum[i][T], T <= S/2, O(n S)
Subset sum: a subset of array sums to T;DP CanMakeSum[i][T], O(n S)
0-1 Knapsack: max weight, items with values and weights, maximize value;DP Best[i][w] O(n W)
Maximum path sum in a binary tree;recursive, only left, only right, both. O(n)
Next Greater element in an array;using a stack, O(n)/O(n)
Bottom view of binary tree;BFS with (ordered) map: M[x-coordinate] = value. O(n)/O(n)
Check if a binary tree is subtree of another binary tree;Naive O(n^2), O(n): inorder and preorder of subtree must be substrings of big tree
A*: idea, difference with dijkstra;choose vertex which score minimizing distance processed vertices and _distance to target_
MergeSort: space complexity;O(n) auxiliary
Heapify: algorithm and complexity;O(n) when heapifying from the lower levels to the upper levels, "sinkdown" roots of subtrees
Reverse an array without affecting special characters;O(n) one passe, in-place: two pointers at start and end<br>swap or skip and meet in the middle<br>O(n)|O(1) aux
Count triplets with sum smaller than a given value in O(n^2);sort, loop for first element, use two-pointer-sum<br>O(n^2)|O(1) aux
Convert array into Zig-Zag fashion: distinct element or not cases;distinct O(n)|O(1) aux bubble sort-like swap<br>not distinct QuickSelect to find median, partition
Smallest subarray with sum greater than a given value;Keep adding array elements while current sum is smaller than x<br>If current sum becomes greater than x, update min length, remove starting elements
Stock Buy Sell to Maximize Profit (buy & sell multiple times);1. Find the local minima and store it as starting index. If not exists, return.<br>2. Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.<br>3. Update the solution (Increment count of buy sell pairs)<br>4. Repeat the above steps if end is not reached.
Union-find: naive + 2 optimizations;naive: attach root of x to root of y. Union by rank: attach smaller tree to larger. Path compression: when find is used, nodes on the path to root point to the root (recursive).
Union-find complexity with optimization;amortized O(1) in time|O(n) space.
Topological sort: BFS-style algorithm;find vertices of in-degree 0, process, remove edges to other vertices, repeat
Reverse order of words;reverse string character by character, reverse within each word
