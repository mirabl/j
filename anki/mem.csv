Graph: Complexity of Breadth First Traversal for a Graph;O(V + E) if adjacency list, O(V^2) if adjacency matrix/O(V)
Graph: Complexity of Depth First Traversal for a Graph;time: O(V + E) if adjacency list, O(V^2) if adjacency matrix/O(V) 
Graph: Topological sort of DAG (2); 1. DFS with stack: push to stack after calling DFS on adjacent vertices (so they are on the stack below). O(V + E). 2.  BFS-style algorithm: find vertices of in-degree 0, process, remove edges to other vertices, repeat
Graph: Bridges in a Graph;Naive: remove edge, see if graph is still connected: O(E (V + E)). Better algorithm based on DFS O(V + E) exists.
LinkedList: Detect beginning of a cycle;method1: count cycle length, count first segment length. method2: smarter, TODO. O(n)
Tree: Check if a binary tree is subtree of another binary tree;Naive O(n^2), O(n): inorder and preorder of subtree must be substrings of big tree
Array: Reverse an array without affecting special characters;O(n) one pass, in-place: two pointers at start and end<br>swap or skip and meet in the middle<br>O(n)|O(1) aux
Array: Convert array into Zig-Zag fashion: distinct element or not cases;distinct O(n)|O(1) aux bubble sort-like swap<br>not distinct QuickSelect to find median, partition
Array: Smallest subarray with sum greater than a given value;Sliding window: keep adding array elements while current sum is smaller than x<br>If current sum becomes greater than x, update min length, remove starting elements
Array: Stock Buy Sell to Maximize Profit (buy & sell multiple times);1. Find the local minima and store it as starting index. If not exists, return.<br>2. Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.<br>3. Update the solution (Increment count of buy sell pairs)<br>4. Repeat the above steps if end is not reached.
Union-find: naive + 2 optimizations;naive: attach root of x to root of y. Union by rank: attach smaller tree to larger. Path compression: when find is used, nodes on the path to root point to the root (recursive).
Union-find complexity with optimization;amortized O(1) in time|O(n) space.
Sudoku Solver;Backtracking. Only check if one value is already in a row/col/square.
Union-find complexity with optimizations;amorted almost O(1) with path compression and union by rank (O(1/ackermann(n)))
Graph: Find connected components of a graph;BFS/DFS O(V + E), keep track of components with Union-Find.
Graph: Detect cycle in a graph;DFS look for back-edge O(V + E). Also possible with Union-Find: loop on edges, union-find on vertices O(E)?
SD: RAM R/W speed;10 GB/s
SD: SSD R/W speed;500 MB/s
SD: HDD R/W speed;100 MB/s
SD: RAM latency;100 ns
SD: SSD latency;0.1 ms
SD: HDD latency;10 ms, disk seek
Array: Find maximum in sliding window;1. use self-balanced BST O(n log n). 2. Use dequeue keeping only useful elements O(n)
Array: Rotate an array;1. With a temp array of size K. 2. With cycles (compute gcd)
String: Reverse words in a sentence;1. Word by word from the end. 2. reverse whole string char-by-char, reverse within each word
String: Regex matching;Recursive, DP
Tree: Check if a tree is a BST (2);1. recursive propagate min/max O(n), 2. check if in-order traversal is sorted
Tree: Convert BT to doubly LL;TODO
Tree: Print tree perimeter (border);print left boundary without leaf, print leaves, print right in reverse (recursive)
Tree: Connect same level siblings;BFS level order
Tree: Serialize/Deserialize;Special case? BST, complete, full?. Inorder array with null marker
Tree: Inorder sucessor in BT with parent pointer;If right subtree of node is not NULL, successor in minimum of right subtree. Else then succ is one of the ancestors. Travel up using the parent pointer until you see a node which is left child of it’s parent. The parent of such a node is the succ. O(h)
Tree: Inorder sucessor in BT without parent pointer;Search from root O(h). Instead of traveling up with parent pointers: Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.
Tree: k-th highest element of BST;reverse inorder traversal of BST. O(h + k)




