SD apps: how many Kafka messages per second at Uber<br><br>how much storage at FB/YT	billions<br><br>500+ PB
Geo: nearest neighbour	k-d tree<br>2D: Voronoi
Tree: find lowest common ancestor of two nodes in a binary tree (not BST)	1. find path to x to y find last common element. O(n) 2 traversals. <br><br>2. rec: LCA has one node on each side. O(n) 1 traversal.
String: Find the smallest window in a string containing all characters of another string	sliding window O(n)|O(n)
LinkedList: insertion in linked list tip	use dummy first node
SD primitives: replication algorithms that maintain single-copy consistency	1n msg: asynchronous primary/backup<br><br>2n msg: synchronous primary/backup<br><br>4n msg: 2-phase commit, Multi-Paxos<br><br>6n msg: 3-phase commit, Paxos with repeated leader election
SD primitives: 2 rate limiters	leaky bucket, token bucket
SD low-level: RAM SSD HDD latency	RAM 100 ns<br>SSD 0.1 ms    (x1000)<br>HDD 10 ms    (x100)
SD: how many FB users	2B Montly active users
Sort: sort when element are nearly sorted (2 ways)	heapsort<br>insertion sort
String: Edit Distance	DP O(mn)
Bit: test if a number is a power of two	(n & (n-1)) == 0
QuickSort: best and worst case of QuickSort<br><br>Memory complexity:	best: pivot splits array in half each time O(n log n)/O(log n)<br>worst: pivot is min (or max), O(n^2)/O(log n)<br><br>Memory: O(log n) with in-place partitioning
SD components: default replication of MySQL	async primary/backup
SD components: 2 Kafka guarantees	at-least-one<br>in order within a partition only
Alg: NP-complete/NP-hard definition	in NP, and any NP problem can be transformed in a NP-complete<br><br>NP-hard: same but not in NP necessarily
Sort: 6 questions on data	how many keys, duplicates, partially sorted, long to compare, small range, disk access possible
SD primitives: 3 implementations of strong consistency	Primary/backup<br>2PC (CA)<br>Paxos (CP)
Tree: iterative in-order traversal of binary tree	stack and curnode pointer
Tree: iterative in-order traversal of binary tree	stack and curnode pointer
Prob: find K-th smallest pair distance<br>from integer array	Sort array<br>Binary search on answer<br>Two pointer to validate
SD primitives: weak consistency models	client-centric: ex. client will never see older value<br><br>causal (strongest): <br><br>eventual: after some time all replicas agree
Lang: pure virtual function	has to be implemented by a class that is not abstract
SD low-level: RAM SSD HDD R/W speed	RAM 10 GB/s<br>SSD 500 MB/s    (/20)<br> HDD 100 MB/s    (/5)
DS: suffix tree	compressed trie of suffixes<br>naive O(n^2) construction time, O(n^2) space<br>compressed: O(n) space<br>smart construction in O(n)
Graph: bridge<br>def, algo	remove this edge and there is no path left between u and v<br><br>O(V + E) DFS looking at backedges and visiting time
Algo: 5 problems solved by sweep line	closest pair<br>union of rectangles<br>convex hull<br>line intersection<br>Voronoi diagrams
Tree: Inorder sucessor in BT with parent pointer	If right subtree of node is not NULL, successor in minimum of right subtree. <br>Else then succ is one of the ancestors. <br>Travel up using the parent pointer until you see a node which is left child of itâ€™s parent. <br>The parent of such a node is the succ. O(h)
Graph: Detect cycle in a graph	Colorized DFS look for back-edge O(V + E).<br><br> Also possible with Union-Find: loop on edges, union-find on vertices O(E)?
SD: topics to address	HA, scaling, sizing, discovery, latency, build whole system with client
3 big sorts on large data<br>+ advantages	quicksort: fast, not stable unless storage<br><br>merge sort: stable, parallelizable, works on lists, contiguous access<br><br>heap sort: in-place, slower than quicksort
Merge intervals	sort by start, <br>one pass <br><br>O(nlog n)|O(n)
Quicksort: pivot choosing methods? (3)	first, <br>random, <br>median of random 3
SD: vertical/horizontal scaling 	vertical: add more power to a machine<br><br>horizontal: add more machines
SD components: advantage/disadvantage of columnar storage, 3 examples	if usage pattern is to read whole table like OLAP/BI<br>but only some columns<br>don't read unused columns<br>can use compression to reduce size on disk<br>disadv: difficult to update<br>Parquet, Redshift, Dremel/BigQuery
Graph: vertex cover, difficulty of minimum VC	set of vertices such that each edge is incident to at least one vertex of the set<br>minimum VC: NP-hard
Sort: name of sort which preserves original order for same key values	stable sort
Tree: reconstruct tree from inorder and preoder	find root, left inorder, right inorder etc.<br>recurse
Geo: range query	given set of points<br>query: for a query region Q, which points are in Q?<br><br>k-d tree<br>Delaunay triangulation if dynamic
SD: 2 types of failover	active-passive (master-slave)<br><br>active-active (master-master)
Tree: k-th highest element of BST	reverse inorder traversal of BST. O(h + k)
SD: how many YT videos watched every day	5B
SD: Master-slave replication	The master serves reads and writes, replicating writes to one or more slaves, which serve only reads. <br>Slaves can also replicate to additional slaves in a tree-like fashion. <br>If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.
Prob: swim in rising water	BS on answer + DFS check<br>O(n^2 log n)<br><br>BFS with priority queue<br>O(n^2 log n)
Array: find the majority element	Boyer-Moore voting algorithm O(n)
LinkedList: Select random node from linked list	method1: naive count nodes in first pass. <br><br>method2:reservoir sampling O(n) one pass.
SD components: BigTable data model	row (row key), column: column families + column qualifier within family, + timestamp<br>sparse: no room taken for empty cells
Math: number of trailing zeroes in a factorial	powers of 2, 5
