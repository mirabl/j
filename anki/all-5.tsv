SD apps: how many Kafka messages per second at Uber<br><br>how much storage at FB/YT	billions<br><br>500+ PB
Geo: nearest neighbour<br>- definition<br>- solved with	k-d tree<br>2D: Voronoi
Tree: find lowest common ancestor of two nodes in a binary tree (not BST)	1. find path to x to y find last common element. O(n) 2 traversals. <br><br>2. rec: LCA has one node on each side. O(n) 1 traversal.
String: Find the smallest window in a string containing all characters of another string	sliding window O(n)|O(n)
LinkedList: insertion in linked list tip	use dummy first node
SD primitives: replication algs with single-copy consistency (+ nb of msg)	1n msg: asynchronous primary/backup<br><br>2n msg: synchronous primary/backup<br><br>4n msg: 2-phase commit, Multi-Paxos<br><br>6n msg: 3-phase commit, Paxos with repeated leader election
SD primitives: 2 rate limiters	leaky bucket, token bucket
Sort: sort when element are nearly sorted (2 ways)	insertion sort<br>heapsort
String: Edit Distance algo, complex	DP O(mn)
Bit: test if a number is a power of two	(n & (n-1)) == 0
QuickSort: best and worst case of QuickSort<br><br>memory complexity	best: pivot splits array in half each time O(n log n)/O(log n)<br>worst: pivot is min (or max), O(n^2)/O(log n)<br><br>Memory: O(log n) with in-place partitioning
SD components: default replication of MySQL	async primary/backup
SD components: 2 Kafka guarantees	at-least-one<br>in order within a partition only
Alg: NP-complete/NP-hard definition	in NP, and any NP problem can be transformed in a NP-complete<br><br>NP-hard: same but not in NP necessarily
Sort: 6 questions on data	how many keys, duplicates, partially sorted, long to compare, small range, disk access possible
SD primitives: 3 implementations of strong consistency	Primary/backup<br>2PC (CA)<br>Paxos (CP)
Tree: iterative in-order traversal of binary tree	stack and curnode pointer
Prob: find K-th smallest pair distance<br>from integer array	Sort array<br>Binary search on answer<br>Two pointer to validate
SD primitives: 3 weak consistency models	causal (strongest)<br><br>client-centric/session: ex. client will never see older value, read-my-writes<br><br>eventual: after some time all replicas agree
SD low-level: RAM SSD HDD latency and R/W speed	RAM 100 ns<br>SSD 0.1 ms    (x1000)<br>HDD 10 ms    (x100)<br><br>RAM 10 GB/s<br>SSD 500 MB/s    (/20)<br> HDD 100 MB/s    (/5)
DS: suffix tree<br>- definition<br>- complexities	compressed trie of suffixes<br>naive O(n^2) construction time, O(n^2) space<br>compressed: O(n) space<br>smart construction in O(n)
Graph: bridge<br>def, algo, complexity	remove this edge and there is no path left between u and v<br><br>O(V + E) DFS looking at backedges and visiting time
Algo: 5 problems solved by sweep line	closest pair<br>union of rectangles<br>convex hull<br>line intersection<br>Voronoi diagrams
Graph: Detect cycle in a graph<br>(2 ways, complexity)	Colorized DFS look for back-edge O(V + E).<br><br> Also possible with Union-Find: loop on edges, union-find on vertices O(E)?
Sort:<br>3 big sorts on large data<br>+ advantages	quicksort: fast, not stable unless storage<br><br>merge sort: stable, parallelizable, works on lists, contiguous access<br><br>heap sort: in-place, slower than quicksort
Prob:<br>Merge intervals	sort by start, <br>one pass <br><br>O(nlog n)|O(n)
SD components: advantage/disadvantage of columnar storage, 3 examples	if usage pattern is to read whole table like OLAP/BI<br>but only some columns<br>don't read unused columns<br>can use compression to reduce size on disk<br>disadv: difficult to update<br>Parquet, Redshift, Dremel/BigQuery
Graph: vertex cover, difficulty of minimum VC	set of vertices such that each edge is incident to at least one vertex of the set<br>minimum VC: NP-hard
Tree: reconstruct tree from inorder and preorder	find root, left inorder, right inorder etc.<br>recurse
Geo: range query<br>- def<br>- solved with	given set of points<br>query: for a query region Q, which points are in Q?<br><br>k-d tree<br>Delaunay triangulation if dynamic
SD: 2 types of failover	active-passive (master-slave)<br><br>active-active (master-master)
Tree: k-th highest element of BST	reverse inorder traversal of BST. O(h + k)
SD:<br>- how many FB users<br><br>- how many YT videos watched every day	- 2B Montly active users<br><br>- 5B
Prob: swim in rising water	BS on answer + DFS check<br>O(n^2 log n)<br><br>BFS with priority queue<br>O(n^2 log n)
Array: find the majority element	Boyer-Moore voting algorithm<br><br>O(n)
LinkedList: Select random node from linked list (2)	method1: naive count nodes in first pass. <br><br>method2:reservoir sampling O(n) one pass.
SD components: BigTable: data model, API, 2 open source equivalents	1. row (row key)<br>2. column: column families + column qualifier within family<br>3. timestamp<br><br>sparse: no room taken for empty cells<br><br>- lookup by row key, range query<br>- HBase, Cassandra
SD: why Kafka performance (2)	zero-copy<br>batching
OO: abstract class	one or more of methods have no implementation<br><br>serves as base class for others
OO: static class, static member	class: can not be instantiated<br><br>member: one copy exists
SD components: 5 techniques to scale RDBMS<br>general/read/writes	general:<br>- federation<br>- denormalization<br>- SQL tuning<br><br>scale reads:<br>- master-slave replication<br><br>scale writes:<br>- sharding
SD: skip list<br>- definition<br>- complexities<br>- used in	linked list for binary search<br>layers of sorted linked lists (express lanes)<br>p = 1/2 or 1/4, proba for element to be also in layer below<br><br>O(log n) average for search/insert/delete, O(n) average space<br>used in LevelDB MemTable
SD low-level: DMA definition, 3 steps	a device controls processor's memory directly<br>can transfer data to/from memory without processor<br><br>1. CPU initiates transfer<br>2. does other things<br>3. receives interrupt from device when done
SD: How many simultaneous connections on a whatsapp server	2 million
SD low-level: TCP definition, uses what to be reliable, limitations	reliable, connection-oriented ordered stream of bytes on IP network<br>congestion control<br>seqno and acknowledgments<br><br>no preservation of message boundaries
SD low-level: content of TCP segment (6)	ports, seq no, ackno, flags, checksum, payload
SD low-level: UDP, def, can do/can not do	connectionless, message oriented (datagrams)<br>can broadcast<br><br>can be out-of-order or lost<br>no congestion control
SD meth: system design methodology (6)	1. Scope<br>2. Non-scope<br>3. Usage and existing<br>4. SLO (latency, avail, dura)<br>5. First design<br>6. storage
SD meth: system design methodology for storage (5)	1. data model<br>2. size<br>3. Usage r/w<br>4. SLO<br>5. Bias (popular, geo)
