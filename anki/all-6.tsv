SD: How many simulataneous connections on a whatsapp server	2 million
SD meth: system design methodology (6)	1. Scope<br>2. Non-scope<br>3. Usage and existing<br>4. SLO (latency, avail, dura)<br>5. First design<br>6. storage
SD components: 5 techniques to scale RDBMS<br>general/read/writes	general:<br>- federation<br>- denormalization<br>- SQL tuning<br><br>scale reads:<br>- master-slave replication<br><br>scale writes:<br>- sharding
SD meth: system design methodology for storage (5)	1. data model<br>2. size<br>3. Usage r/w<br>4. SLO<br>5. Bias (popular, geo)
Sort: 6 sort properties	- stable<br>- in place<br>- comparison or not<br>- external<br>- good with pre-sorted<br>method: partition, merge, select, insert, exchange
SD: skip list<br>- definition<br>- complexities<br>- used in	linked list for binary search<br>layers of sorted linked lists (express lanes)<br>p = 1/2 or 1/4, proba for element to be also in layer below<br><br>O(log n) average for search/insert/delete, O(n) average space<br>used in LevelDB MemTable
SD: Consistency in CAP theorem	all nodes see the same data all the time<br><br>equivalent to single-copy of the data
SD: Availability in CAP theorem (2)	every request receives a response about its success<br><br>or any reachable replica is available for reads and writes
SD: Partition tolerance in CAP theorem	system continues to operate despite message loss or failure of part of the system
SD: A in ACID	Atomicity<br><br>All or nothing for a transaction:<br>indivisible<br>done or not done
SD: C in ACID	Consistency<br><br>a transaction moves the DB from a valid state to other valid state (e.g. preserve unique keys)<br><br>Not the same as C in CAP
SD: I in ACID	concurrent execution of transactions leaves the DB in same state than if the they were executed sequentially
SD: D in ACID	when a transaction is committed, it will remain committed even in the case of a system failure (power, crash)
SD low-level: OSI and TCP/IP models	OSI: PDNTSPA<br><br>TCP/IP: NITA
SD low-level: DMA definition, 3 steps	a device controls processor's memory directly<br>can transfer data to/from memory without processor<br><br>1. CPU initiates transfer<br>2. does other things<br>3. receives interrupt from device when done
SD low-level: TCP definition, uses what to be reliable, limitations	reliable, connection-oriented ordered stream of bytes on IP network<br>congestion control<br>seqno and acknowledgments<br><br>no preservation of message boundaries
SD low-level: content of TCP segment (6)	ports, seq no, ackno, flags, checksum, payload
SD low-level: UDP, def, can do/can not do	connectionless, message oriented (datagrams)<br>can broadcast<br><br>can be out-of-order or lost<br>no congestion control
OO: abstract class	one or more of methods have no implementation<br><br>serves as base class for others
OO: 3 characteristics of OO	inheritance<br>encapsulation<br>polymorphism
OO: virtual method	can be overriden in derived class
OO: 2 aspects of polymorphism	1. at run time, object of derived class can be treated as base class<br><br>2. virtual methods of base class can be overriden
OO: static class, static member	class: can not be instantiated<br><br>member: one copy exists
OO: member overloading	same name but different signature
OO: generics	class/method that defer specification of type until declared and instantiated in client code
SD: circuit breaker<br>def, how it works	proxy for operations that might fail<br><br>states: closed / half-open / open<br>change state by looking at error rate
SD: retry pattern	depending on error from service, client can have 3 strategies<br>- retry immediately<br>- retry later<br>don't retry<br><br>careful: idempotency prefered
SD components: load balancer used for (3), implemented with (2)	- don't send to bad servers<br>- don't overload<br>- eliminate SPOF<br><br>- hard or soft (HAProxy)
SD components: load balancer multi setup (2)	active-passive or active-active
SD components: load balancer routes traffic based on (6)	- random<br>- least load<br>- session/cookies<br>- (weighted) round robin<br>- layer 4<br>- layer 7
SD components: load-balancer layer 4 vs. layer 7	4:<br>- look at transport layer: IP address, port<br>- do NAT<br>- often hardware<br><br>7:<br> look at application layer, like URL for HTTP, cookies<br>terminates network traffic, remove TLS<br>called reverse-proxy server
SD: event-sourcing pattern	use append-only store of actions/events
SD: CQRS	command query responsibility separation<br>separate read and write of data
SD DS: SSTable<br>def, internals, read, write	persistent ordered immutable on disk<br>Index and Data blocks<br>Index (in-memory): PK (ex. B-Tree) and offsets in Data<br>Data 64KB block: key-value pairs<br>optimised for reads, written sequentially<br>no in-place changes
SD components: Kafka perf: factors<br>produce, consume, latency	depends on: message size, replication (number and sync/async)<br><br>producer: 700K msg/s<br>consumer: 1M msg/s<br>end-to-end latency: ~3ms 99p
SD: SLO for S3 (2)	99.99 (4) availability<br><br>99.99999999 (10) durability
SD: three and four nines availability per year	99.9: 9 hours of downtime/year<br><br>99.99: 1 hour downtime/year
SD DS: MemTable and SSTable<br>stored where, read/writes, maintenance	MemTable in memory, SSTable on disk mostly<br>writes go to MemTable<br>reads go to MemTable first<br>periodically:<br>- MemTable flushed to disk SSTable <br>- SSTable collapsed together
SD components: in-memory K/V store perf	on machine with good network<br><br>read/write: 200k/s easily<br><br>latency: 1ms<br><br>no bound on size with sharding but $
SD: SLO types per system type (3)	always: correctness<br><br>user-facing requests: availability, latency, throughput<br><br>storage: latency, availability, durability<br><br>pipeline: throughput, end-to-end latency
SD methodology: 3 questions to task on iteration	possible to scale?<br>can do better?<br>resilient?
SD: latency of operation with Paxos between DCs	25ms
SD: chat	end-to-end encryption? multi device? history on server? ack?<br><br>message delivery queue for offline clients<br>balanced read-write<br>low-latency delivery when recipient online<br>many online clients<br>XMPP
SD: URL shorten	lookup/create<br>read-heavy, load-latency read, metadata store, independent entries, mostly immutable<br>lookup by key<br>data bias+, memory cache<br>key generation for shortened URLs?
SD: youtube	view/upload<br>read heavy but long tail of uploads<br>metadata and blob stores<br>data bias++
SD: instagram	metadata+blob store<br>read heavy, bias++, immutable<br>image compression pipeline<br>memory cache<br>e.g. FB Haystack for blob store<br>news feed
SD: docs	metadata+documents<br>can compress text<br>handle conflicts<br>handle offline
SD: citymapper	complex data model<br>latency of read queries with real-time info<br>some pre-computation
SD: search	online queries vs. offline batch crawleringest<br>low latency lookup<br>data size challenge<br>handle complex queries<br>bias++
SD: C numbers	BR 1M/s<br>NoSQL cache/persisted: 200To, 1k memcache, 1k couchbase, 1ms 99p, 60M QPS peak<br><br>HDFS: 300 PB, 3k nodes