String: Longest Substring Without Repeating Characters	Window. left and right pointers, hash set for characters in the substring, move either left or right O(n)|O(n) // traverse left to right, maintaining longest valid substring ending at this position, use map<char,position> to know where current character appeared last O(n)|O(n)
Tree: Print tree perimeter (border)	print left boundary without leaf,<br> print leaves, <br>print right in reverse (recursive)
Tree: Inorder sucessor in BST without parent pointer	Search from root O(h). <br>Instead of traveling up with parent pointers: Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.
DS: implement a queue using two stacks	empty first stack into second stack
SD: vertical/horizontal scaling 	vertical: add more power to a machine<br><br>horizontal: add more machines
SD apps: mechanism for asynchronicity	queues
DS: external merge sort	sort chunk & write to disk, load chunk of chuck and merge-write
Sort:<br>Selection and Insertion sort: best and worst case	- Selection: no difference, <br>always O(n^2)/O(1) auxiliary<br><br>- Insertion: sorted O(n)/O(1) aux<br>worst: reverse sorted O(n^2)/O(1) aux
Sort: bubble sort	swap pairs to put max at i=end of array<br>i--
SD: Federation	= functional partitioning<br><br>splits up databases by function. <br><br>For example, forums, users, and products
Array: find subarray with maximum sum	one pass, accumulate (Kadane)<br><br>at each position either extend or start new subarray O(n)|O(1)
Array: 3Sum  Find all unique triplets in the array which gives the sum of zero	sort, loop for first element and then 2sum sweep, <br>avoid duplicates by avoiding duplicate first element <br>O(n^2)|O(1)
Sort: insertion sort<br>selection sort	insertion: insert A[i] in sorted A[0]...A[i-1]<br><br>select min put it at A[i=0], i++
Stack: implement stack with O(1) min<br>(2 ways)	push (x, min) when pushing x, <br><br>or use second stack
Prob:<br>Search: find element in row-and-column-sorted matrix	start from NE corner
SD: replication lag for MySQL	time between read/write to master and replication to all slaves
Array: 2sum (3 ways)	same element twice?<br> Use hash table O(n)|O(n), <br>sort+two pointers O(n log n)|O(1), <br>sort+BS O(n log n)|O(1)
SD: drawback of DNS load balancing	results are cached by intermediate servers, so not responsive when change
Prob: Sudoku Solver	Backtracking<br><br>check if one value is already in a row/col/square, recurse
LinkedList: Sort a linked list	use merge sort
SD apps: Back pressure	feedback mechanism used by producers to let know consumers how they should adjust their requests
Math: number of trailing zeroes in a factorial	powers of 2, 5
Tree: from array, create BST with minimal height	sort, <br>take middle of array then recursive
SD: NoSQL	 is a collection of data items represented in a key-value store, document-store, wide column store, or a graph database. <br>Data is denormalized, and joins are generally done in the application code.
SD components: when to use BigQuery/Dremel<br>when to use MapReduce	BigQuery: any query, SQL-like, no latency, small output (stats)<br><br>MapReduce: can do any processing, more latency, have to implement all jobs
MergeSort:<br>- time: best and worst case<br>- memory	time: always O(n log n)<br><br>memory: O(n) aux
String: determine if a string has only unique characters (2)	use a set, <br><br>or <b>sort</b> the string
Alg: P, NP definition	solvable in polynomial time<br>a solution can be verified in polynomial time
SD components: OLTP, OLAP	online transaction/analytical processing<br>RDBMS vs. datawarehouse<br>low vs high latency
DS: good sort for a linked list	good: merge sort<br><br>possible but more difficult?: quick sort
SD: how many seconds in a day	90K
Array: Rotate an array<br>(3 ways)	1. naive, step by step<br><br>2. With a temp array of size K. <br><br>3. With cycles (compute gcd)
Array: Convert array into Zig-Zag fashion: distinct element or not cases	distinct O(n)|O(1) aux bubble sort-like swap <br> not distinct QuickSelect to find median, partition O(n)
String: Is a string with (), {}, [] balanced	<b>stack</b> with active items O(n)
Array: Count triplets with sum smaller than a given value in O(n^2)	sort, loop for first element, use two-pointer-sum <br> O(n^2)|O(1) aux
Array: Print matrix in spiral	four variables top bottom left right. Reduce
SD components: 4 cache strategies	cache aside: app does everything<br><br>write-through: cache interacts with DB<br><br>write-behind/back: app writes to cache and async write to DB<br><br>refresh ahead: auto refresh by cache
SD components: replication modes of MySQL<br>(what is in the WAL)	statement-based ("insert ...") = logical<br><br><br>row-based: result of the statement = physical<br><br>or a mix
Tree: Check if a tree is a BST (2)	1. recursive propagate min/max O(n), <br>2. check if <b>in-order traversal</b> is <b>sorted</b> O(n)
Sort: merge sort	merge sorted subarrays with auxiliary array (allocate once)
Sort: sort when limited range of keys	counting sort O(n + k)/O(n + k)<br><br>bucket sort O(n + k)/O(nk)<br><br>radix sort O(w n)/O(w + n)
LinkedList: is a linked list a palindrome?	reverse second half, check (and restore)
SD: CQRS	command query responsibility separation<br><br>separate read and write of data
LinkedList: insertion in linked list tip	use dummy first node
Sort: sort when element are nearly sorted (2 ways)	insertion sort<br>heapsort
String: Edit Distance algo, complex	DP O(mn)
Bit: test if a number is a power of two	(n & (n-1)) == 0
SD components: default replication of MySQL	async primary/backup
QuickSort: best and worst case of QuickSort<br><br>memory complexity	best: pivot splits array in half each time O(n log n)/O(log n)<br>worst: pivot is min (or max), O(n^2)/O(log n)<br><br>Memory: O(log n) with in-place partitioning
Prob:<br>Merge intervals	sort by start, <br>one pass <br><br>O(nlog n)|O(n)
Tree: k-th highest element of BST	reverse inorder traversal of BST. O(h + k)
LinkedList: Select random node from linked list (2)	method1: naive count nodes in first pass. <br><br>method2: <b>reservoir</b> sampling O(n) one pass.
OO: member overloading	same name but different signature
String: substring search (3)	naive O(n*m) <br><br>robin-karp rolling hash O(n + m) <br><br>Boyer-Moore: O(n/m) to O(nm)
SD components: NoSQL 4 types of stores	key-value: Redis, memcached<br><br>document store: MongoDB, CouchDB, ElasticSearch<br><br>wide-column store: BigTable, HBase, Cassandra<br><br>graph DB: neo4j, flockdb
SD: Denormalization	improve read perf at the expense of write perf. <br>Redundant copies of the data are written in multiple tables to avoid expensive joins. 
SD primitives: how are conflicts resolved (2)	look at causal history with <b>metadata</b><br>last writer, timestamps, version numbers, vector clocks
Prob:<br>Max number of intersecting intervals	<b>sort</b> events: <b>enter</b> and <b>exit</b> of intervals.<br><br>O(n log n)|O(n) aux
Algo: pseudo-polynomial time	running time polynomial in the numeric value of input<br>but exponential in the length of the input
Graph: A*: idea, difference with dijkstra	choose vertex which score minimizing distance processed vertices and <b>distance to target</b>
Prob:<br>Product of array except self	two steps with <b>left+right prefix product</b><br><br>no need of additional array
Tree: Bottom view of binary tree	BFS with (ordered) map: <br>M[x-coordinate] = value<br><br>O(n)/O(n)
SD primitives: split brain	failover to backup due to temporary network issue<br>primary and backup are active at the same time
SD primitives: N, R, W, usual recommendation	N replicas,<br>need R/W votes for read/write<br>R + W > N
Sort:<br>QuickSort: algorithm	(randomize first), <br>select pivot, <br>partition, <br>sort left and right partition
Sort:<br>Heapsort: description, complexity	<b>heapify in O(n)</b><br>n times: get max, put at end, resize heap O(log n)<br><br><b>total: O(n log n)</b>
Prob:<br>combination sum: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T., <br>same number can be repeated<br>	backtracking (or DP)
SD components: ETL	extract data from multiple sources<br><br>clean, join, aggregate, transform into format<br><br>load in warehouse
Array: Reverse an array without affecting special characters	O(n) one pass, in-place: two pointers at start and end <br> swap or skip and meet in the middle <br> O(n)|O(1) aux
SD: event-sourcing pattern	use append-only store of actions/events
SD: in MySQL master-slave, how to ensure read-after-write has most recent value	read from Master
Heap: complexity and algo of insert, extract-min, search	use <b>last element</b>, bubble up or down<br>O(log n)<br><br>search: difficult O(n)
DS:<br>Union-find: naive + 2 optimizations.<br>Complexity.	naive: attach root of x to root of y. <br>Union by rank: attach smaller tree to larger. <br>Path compression<br><br>Amortized O(1) in time |O(n) space.
DS: check if item is in known set	<b>Bloom filter</b> if no space for hash table
SD apps: 2 difficulties of streaming systems	order<br>exactly once delivery
SD low-level: L1/L2 cache, main memory reference	 L1 1 ns<br>L2 10 ns (x10)<br>main memory 100 ns (x10)
SD apps: most followers on twitter	1B
SD components: tablet definition	horizontal partition/shard of a table (Google)
SD: Geo load-balancing with DNS	some DNS servers have IP range tables and can have different responses for different ranges
SD: tunable consistency	from "writes never fail" to <br><br>"block for all replicas to be readable" with quorum levels
Search: find element in a sorted rotated array	<b>double BS</b>: <br><br>find the frontier, <br>BS on left or right part
Array: Minimum difference partition	DP CanMakeSum[i][T] <br>T <= S/2<br>O(n S)
SD primitives: why impossible to availability and strong consistency during network partition	<b>divergence</b><br><br>can not prevent divergence if partitioned nodes continue to work
Array: Next Greater element in an array (2)	- from right to left, using a stack<br><br>- or left to right with stack, but map also<br><br>O(n)/O(n)
Combinatorics: compute<br>subsets of a set<br>permutations of a set	subsets: recursive, or iterative<br><br>permutations: recursive
SD apps: how many Kafka messages per second at Uber<br><br>how much storage at FB/YT	billions<br><br>500+ PB
SD components: 2 Kafka guarantees	at-least-once<br>in order within a partition only
Tree: reconstruct tree from inorder and preorder	find root, left inorder, right inorder etc.<br>recurse
Array: find the majority element	Boyer-Moore <b>voting</b> algorithm<br><br>O(n)
SD components: 5 techniques to scale RDBMS<br>general/read/writes	general:<br>- federation<br>- denormalization<br>- SQL tuning<br><br>scale reads:<br>- master-slave replication<br><br>scale writes:<br>- sharding
SD components: load balancer multi setup (2)	active-passive or active-active
SD apps: chat, +protocol	end-to-end encryption? multi device? history on server? ack?<br>push updates: websocket?<br>message delivery queue for offline clients<br>low-latency delivery when recipient online<br>many online clients<br>XMPP
SD apps: URL shortener	lookup/create<br>read-heavy, load-latency read, metadata store, independent entries, mostly immutable<br>lookup by key<br>data bias+, memory cache<br>key generation service for shortened URLs? maybe offline
SD apps: youtube	view/upload<br>read heavy but long tail of uploads<br>metadata and blob stores<br>data bias++<br>video processing pipeline
SD apps: instagram	features: feed, by user list, upload<br>metadata+blob store<br>read heavy, bias++, immutable<br>image compression pipeline<br>memory cache<br>e.g. FB Haystack for blob store
SD apps: docs	metadata+documents<br>can compress text<br>handle conflicts<br>handle offline
SD apps: citymapper	complex data model<br>latency of read queries with real-time info<br>some pre-computation
SD apps: search	- <b>index servers</b> (random sharded on docs)<br>- <b>doc servers</b> (same)<br><br>scatter: build hit list<br>gather: compute relevance order<br><br>docserver: fetch doc from disk, get snippet for keyword
Array: rotate image by 90 degrees (3)	- ring by ring, <br><br>- reverse up to down and transpose<br><br>- if n=2^k, recursive quadrants
