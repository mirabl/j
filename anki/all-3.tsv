2D Array: Boggle (Find all possible words in a board of characters)	DFS from every start cell, mark visited cells.<br><br>Complexity?<br> Better solution with Tree.
Array: rotate image by 90 degrees	ring by ring, <br><br>or reverse up to down (r2l) and transpose
Coin Game: coins in a row, pick one	windowed DP<br><br>DP F(from i-th coin to j-th coin) = max(. + min(), . + min())<br>O(n^2)
Combinatorics: compute<br>subsets of a set<br>permutations of a set	subsets: recursive, or iterative<br><br>permutations: recursive
Graph: shortest path when edges have no weight	BFS
Heap: complexity and algo of insert, extract-min, search	use last element, bubble up or down<br>O(log n)<br><br>search: difficult O(n)
LinkedList: is a linked list a palindrome?	reverse second half, check (and restore)
LinkedList: Select random node from linked list	method1: naive count nodes in first pass. <br><br>method2:reservoir sampling O(n) one pass.
Sort: insertion sort<br>selection sort	insertion: insert A[i] in sorted A[0]...A[i-1]<br><br>select min put it at A[i=0], i++
String: Find the smallest window in a string containing all characters of another string	sliding window O(n)|O(n)
String: determine if a string has only unique characters (with and without memory)	use a set, <br><br>or sort the string
Search: find element in a sorted rotated array	double BS: <br><br>find the frontier, <br>BS on left or right part
Selection and Insertion sort: best and worst case	- Selection: no difference, <br>always O(n^2)/O(1) auxiliary<br><br>- Insertion: sorted O(n)/O(1) aux<br>worst: reverse sorted O(n^2)/O(1) aux
DS: implement a queue using two stacks	empty first stack into second stack
Tree: Check if binary tree is full (not complete)	recursive O(n)
Tree: from array, create BST with minimal height	sort, <br>take middle of array then recursive
Tree: iterative in-order traversal of binary tree	stack and curnode pointer
Array: Smallest subarray with sum greater than a given value	Sliding window: keep adding array elements while current sum is smaller than x <br> If current sum becomes greater than x, update min length, remove starting elements
Array: Stock Buy Sell to Maximize Profit (buy & sell multiple times)	1. Find the local minima and store it as starting index. If not exists, return. <br> 2. Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index. <br> 3. Update the solution (Increment count of buy sell pairs) <br> 4. Repeat the above steps if end is not reached.
combination sum: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T., <br>same number can be repeated<br>	backtracking (or DP)
Container With Most Water	two pointers, from start and end, <br>reduce width and stop only when height increases, <br><br>O(n)|O(1)
Graph: Topological sort of DAG (2)	 1. DFS: prepend to list after calling DFS on adjacent vertices (so they are on the stack below). O(V + E). <br>2.  BFS-style algorithm: find vertices of in-degree 0, process, remove edges to other vertices, repeat
LinkedList: insertion in linked list tip	use dummy first node
0-1 Knapsack: max weight, items with values and weights, maximize value	DP Best[i][w]<br>O(n W)
Array: Convert array into Zig-Zag fashion: distinct element or not cases	distinct O(n)|O(1) aux bubble sort-like swap <br> not distinct QuickSelect to find median, partition O(n)
Array: find subarray with maximum sum	one pass, at each position either extend or start new subarray O(n)|O(1)
Array: find the majority element	Boyer-Moore voting algorithm O(n)
Array: find the median of non-sorted array	QuickSelect O(n)
Array: Longest Increasing Subsequence	DP O(n^2). <br><br>also possible in O(n log n)<br> with active lists and binary search
Array: Next Greater element in an array	using a stack<br>O(n)/O(n)
Graph: Bridges in a Graph	Naive: remove edge, see if graph is still connected: O(E (V + E)). Better algorithm based on DFS O(V + E) exists.
Graph: Minimum Spanning tree Kruskal: algorithm and complexity	sort edges by weight, <br>(take min edge, check if it introduces a cycle in the partial tree, discard or add). <br>Cycle detection with union-find<br><br>O(E log E)
Graph: Minimum Spanning tree Prim: algorithm and complexity	greedy vertices: add new vertex of minimum distance to partial tree. <br>O(V^2), <br>can be reduced with binary heap.
Longest Palindromic Substring	for each position, find longest even and odd length substring with this center O(n^2)|O(1)<br>DP bottom-up with length-0 length-1 -2 ... substrings O(n^2)|O(1)<br><br>O(n) difficult Manacher.
Max number of intersecting intervals	sort events: enter and exist of intervals. O(n log n)|O(n) aux
Minimum difference partition	DP CanMakeSum[i][T], <br>T <= S/2<br>O(n S)
String: Longest Substring Without Repeating Characters	Window. left and right pointers, hash set for characters in the substring, move either left or right O(n)|O(n) // traverse left to right, maintaining longest valid substring ending at this position, use map<char,position> to know where current character appeared last O(n)|O(n)
String: substring search	naive O(n*m) <br><br> robin-karp rolling hash O(n + m) <br><br> advanced O(n)
Subset sum: a subset of array sums to T	DP CanMakeSum[i][T]<br>O(n S)
Tree: Check if a binary tree is subtree of another binary tree	Naive O(n^2), <br><br>O(n): inorder and preorder of subtree must be substrings of big tree
Tree: Maximum path sum in a binary tree	recursive, only left, only right, both<br>O(n)
Array: Continuous median	maintain 2 big balanced heaps
String: Regex matching	Recursive, DP. With offset going from left to right.
Tree: Inorder sucessor in BST without parent pointer	Search from root O(h). <br>Instead of traveling up with parent pointers: Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.
Tree: Inorder sucessor in BT with parent pointer	If right subtree of node is not NULL, successor in minimum of right subtree. <br>Else then succ is one of the ancestors. <br>Travel up using the parent pointer until you see a node which is left child of it’s parent. <br>The parent of such a node is the succ. O(h)
Array: Given an array of integers, every element appears twice except for one. Find that single one	XOR O(n)
SD low-level: how many round trips per second world-wide/within a data center	world-wide: 6-7<br><br>datacenter: 2000
SD: Master-master replication	Both masters serve reads and writes and coordinate with each other on writes. <br>If either master goes down, the system can continue to operate with both reads and writes.