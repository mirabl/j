Array: Continuous median	maintain 2 big balanced heaps
Array: Find maximum in sliding window	1. use self-balanced BST O(n log n). <br><br>2. Use dequeue keeping only useful elements O(n)
Array: Given an array of integers, every element appears twice except for one. Find that single one	XOR O(n)
Array: Given infinite coins of value (V1, V2, … ,VN), find the minimum number of coins with sum S	DP(n, S)
Graph: Detect cycle in a graph	Colorized DFS look for back-edge O(V + E).<br><br> Also possible with Union-Find: loop on edges, union-find on vertices O(E)?
Graph: Find connected components of a graph	BFS/DFS O(V + E), <br>or just Union-Find with no graph traversal<br><br>If dynamic changes, keep track of components with Union-Find.
SD: Federation	(or functional partitioning) splits up databases by function. <br>For example, forums, users, and products
SD: how many round trips per second world-wide/within a data center	world-wide: 6-7<br><br>datacenter: 2000
SD: L1/L2 cache, main memory reference	 L1 1 ns<br>L2 10 ns (x10)<br>main memory 100 ns (x10)
SD: Master-master replication	Both masters serve reads and writes and coordinate with each other on writes. <br>If either master goes down, the system can continue to operate with both reads and writes.
SD: Master-slave replication	The master serves reads and writes, replicating writes to one or more slaves, which serve only reads. <br>Slaves can also replicate to additional slaves in a tree-like fashion. <br>If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.
SD: NoSQL key-value store	key-value: Redis, memcached<br><br>document store: MongoDB, CouchDB, ElasticSearch<br><br>wide-column store: BigTable, HBase, Cassandra<br><br>graph DB: neo4j, flockdb
SD: RAM SSD HDD latency	RAM 100 ns<br>SSD 0.1 ms    (x1000)<br>HDD 10 ms    (x100)
SD: RAM SSD HDD R/W speed	RAM 10 GB/s<br>SSD 500 MB/s    (/20)<br> HDD 100 MB/s    (/5)
SD: Read 1 MB sequentially from memory, SSD, HDD	memory 250 us,<br> SSD 1 ms    (x4),<br> HDD 20ms    (x20)
SD: Read 4K randomly from SSD	150 us
SD: Send 1K bytes over 1 Gbps network	10 us
SD: how many FB users	2B Montly active users
SD: how many tweets per second, per day	per second: 6000<br><br>per day: 500 million
SD: most followers on twitter	1B
String: Regex matching	Recursive, DP. With offset going from left to right.
Tree: Check if a tree is a BST (2)	1. recursive propagate min/max O(n), <br>2. check if in-order traversal is sorted O(n)
Tree: Inorder sucessor in BST without parent pointer	Search from root O(h). <br>Instead of traveling up with parent pointers: Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.
Tree: Inorder sucessor in BT with parent pointer	If right subtree of node is not NULL, successor in minimum of right subtree. <br>Else then succ is one of the ancestors. <br>Travel up using the parent pointer until you see a node which is left child of it’s parent. <br>The parent of such a node is the succ. O(h)
Tree: k-th highest element of BST	reverse inorder traversal of BST. O(h + k)
Tree: Lowest Common Ancestor in a Binary Search Tree	recursive O(n)
Tree: Serialize/Deserialize	Special case? BST, complete, full?. <br>Inorder array with null marker
Graph: types of graphs	Tree, DAG, bipartite, complete (all clique), intersection, planar
Graph: Strongly Connected Components<br>definition and algo name/cplx	subgraphs s.t. if every vertex is reachable from every other vertex<br><br>Kosaraju DFS O(V + E)