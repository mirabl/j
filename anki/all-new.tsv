Array/subasum: subarray sum (max, shortest >= k, max no more than k)	- max: Kadane O(n)<br><br>- sliding window O(n) or monotonic stack<br><br>- max <= k: O(n log n) using <b>BST upper_bound</b>
Prob: reflex D<br>1. find max less than k (min/more)<br>2. Graph all paths<br>3. count s.t. = K<br>4. count to the right of array	1. <b>BST</b> with upper/lower_bound<br>2. BF backtracking if possible, maybe TSP DP<br>3. count <= K - <= K - 1<br>4. D&C mergesort-like
Geo: horizontal/vertical line intersections	3 events: start/end of horiz, vertical<br><br>keep set of <b>active horiz lines</b> in <b>BST</b><br><br>for a vertical: <b>range search</b> in BST to find intersections
String: <b>Longest Repeated</b> Substring and <b>Longest Common</b> Substring (LCS) with <b>Suffix Tree</b>	- repeated: <b>deepest non-leaf</b> node of ST<br>O(n)<br><br>- common: build ST with 1 <b>terminal symbol</b> for <b>each</b> string<br>find <b>deepest non-leaf</b> with <b>both</b> ends in subtree<br>O(n)
SD primitives: 2 rate limiters (with 1 def)	- <b>leaky bucket</b>: <b>2</b> parameters (burst size=bucket size, rate)<br>><b>increment</b> counter when new request<br><b>decrement</b> counter at given rate<br>reject request if bucket full<br><br>- token bucket
SD/network: network addressing methods (routing schemes) (5)	<b>unicast</b><br><br><b>broadcast</b>: one-to-all, subnet generally<br><br><b>multicast</b>: like broadcast but subset<br><br><b>anycast</b>: to one of many with same IP address (closest), used by CDN<br><br><b>geocast</b>
Prob: stable matching problem (def, solution idea, complex)	= <b>stable marriage</b>problem<br><br>n men, n women<br>every one has <b>order of preference</b> over partners<br>marry such that there is not (1 man, 1 woman) who would rather be together<br><br>solution: <b>rounds</b> with <b>proposals/switches (deferred acceptance)</b> O(n^2)
Prob: assignment problem (def, solution, complex)	<b>maximum-weight matching</b> in weighted <b>bipartite</b> graph<br><br>matchs n agents and n tasks<br>can do any tasks but with diff cost<br><br>O(n^3) Hungarian algo on matrix
String/match: Z-algorithm (idea, complexity)	Z: <b>array</b> of length n<br>Z[i]: longest common prefix between S[0:] and S[i:]<br><br>can be computed in O(n)<br><br>can be used for pattern matching (O(n) P$S)
Graph/cycle: Detect cycle in a graph<br>(dir/undir, complex) (2)	1. <b>Colorized DFS</b> (directed or not): look for <b>back-edge</b><br>undirected: <b>ignore edge to parent</b><br>O(V + E).<br><br>2. <b>Undirected only</b>: <b>Union-Find</b>:<br><b>loop on edges</b>, UF on vertices O(E + V)
Graph/paths: number of paths of length k, APSP of length k	- nb paths: <b>power</b> of <b>adjacency</b> matrix: <b>G^k</b><br><br>O(k n^3)<br><br>O(log k  n^3) with binary exponentiation<br><br>- APSP(k): G^k but with <b>min</b> operator<br>O(n^3 log k)
SD/apps: Dedup system by UID	UID-<b>partitioned</b> workers with local <b>KV store</b> (RocksDB)<br>Fast membership test with LSM DBs (in-mem Bloom)<br><br>Keep UIDs in a time window, <b>expire</b> others:<br>use DB TTL; or <b>secondary index</b> with seqno/ts in <b>column family</b>: <b>sorted iterate</b> to expire<br>worker reads output topic after crash to rebuild state
SD/store: Primary vs. Secondary index	- Primary:  on a key with <b>unique values</b><br>controls <b>sorted storage layout</b> of rows. Multiple columns?<br><br>- Secondary: can be on <b>key with duplicates</b><br>no effect on order
DS algo: complexity analysis (4)	- <b>flatten loops</b> for global count<br><br>- Memoized: NbDiffSubProblems * TimePerSubProblem<br><br>- Recursion with formula<br><br>- Amortization
SD/store: foreign key	field (or several) in one table that <b>uniquely</b> identifies a <b>row</b> of <b>another table</b> (<b>primary</b> or unique key of that table)
SD/cap: CAP (C, A def)	C: every read receives most recent write or error<br><br><br>A: every request receives non-error result with no guarantees that it is most recent write
Prob: Compress jumps along a segment / Painting subarrays offline	use <b>Union-Find</b><br><br>paint:<br>take [l,r],color painting requests in <b>reverse order</B><br><br>store <b>nextUnpainted >= i</b> and use U-F to quickly <b>skip over</b> painted sections
DS/uf: Union-Find optimizations (1, 3)	- <b>path compression</b>: <b>set parent</b> when doing a <b>find</b><br><br>- <b>union</b> (3):<br>a. union by <b>size</b><br>b. union by <b>depth</b><br>c. <b>randomized union</b> (simpler, same complexity)
SD components/store: Cassandra: coordinator	one <b>normal</b> node, can <b>change</b> at any request<br><br>in charge of the <b>whole request</b>:<br>- consistent hash to <b>find nodes</b> to query<br><b>respond to client</b> according to config consistency level 
SD components/store: Cassandra: partitioning, replication, consistency	<b>Consistent hashing</b><br><br>Replication factor: <b>copy</b> to <b>RF</b> machines = neighbors in hash ring<br><br>Consistency read/write levels:<br><br>min numbers of nodes reached by a query<br><br>(One, Quorum=1+RF/2, All)
Array/sided: count smaller elements on the right side (3)	- augmented BST with size field<br>O(n log n)<br><br>- Fenwick/Binary Index Tree<br>O(n log n)<br><br>- BEST: <b>D&C mergesort-based</b><br>avg O(n log n)<br>like <b>inversions</b>
Array/sided: count smaller elements on the right side with <b>D&C</b>	<b>mergesort</b>-based<br><br><br><b>recursively solve</b> for left, right halves (and sort subarrays)<br><br>add count of <b>left/right pairs</b> by <b>sorted-merge step</b><br>O(n log n)
Array/sided: count pairs (x, y) with y in [x + a, x + b] (y to the right of x)	like <b>count smaller elements on the right side</b><br><br><b>D&C mergesort-like</b> O(n log n)<br><br><br>also: BST with size, BIT maybe
Prob/ds: Increment(key), Decrement(key), GetMaxKey(), GetMinKey() all in O(1)	1 <b>Doubly Linked-List</b> for <b>each counter</b> value<br><br>+ <b>HashMap</b> to <b>look up</b> a <b>DLL node</b> by its <b>key</b>
Array/pair: shortest distance pair (x, y) such that y >= x + k (2)	- from <b>right to left</b> with <b>increasing stack</b><br><br>- from <b>left to right</b> with <b>increasing dequeue</b>
String: hashing algo	p = 31, m = 9 + 10^9<br><br>Sum s_i p^i mod m<br><br>p: prime greater than alphabet<br><br>don't map a to 0 (a, aa collide)
Lang: C++ API for custom sort	sort(A.begin(), A.end(), greater<int>())<br><br>bool compare(int x, int j) { return x < y; }<br>sort(., ., compare)
Lang: C++ API for custom Priority Queue	priority_queue<int, <b>vector<int></b>, greater<int>>> Q<br><br>with lambda:<br>auto cmp = [](int left, int right) { return left < right; };<br>priority_queue<int, std::vector<int>, decltype(cmp)> Q(cmp);
Lang: C++ API for custom set/map	like priority queue<br>use builtin (greater)<int><br>or custom lambda<br><br>map<T, <b>T</b>, comp> not map<T, vector<T>, comp>
Prob: Range Sum Query (static, dynamic) (2)	<b>static</b>: easy, just prefix sum<br><br><b>dynamic</b>:<br>- BIT (=Fenwick)<br>- SegmentTree
Prob: Range Minimum Query RMQ (static, dynamic)	<b>static</b>:<br><b>preprocess</b> trade-offs: ex. full lookup<br><br><b>Sqrt decomposition</b> 1D trade-off<br><br><b>Sparse table</b><br>O(1) query, O(n log n)/O(n log n) prepro<br><br>if <b>dynamic</b>: <b>Segment Tree</b><br>O(log n) query/update 
DS: Sparse Table, application, def	<b>static</b> Range Minimum Query<br>easier than <b>Segment Tree</b> when static<br><br>get O(1)?? query but without full O(n^2) lookup<br><br>T[i][k]: minimum of <b>A[i][i+2^k]</b><br><br>build <b>bottom-up</b> DP<br><br>O(1) query, O(n log n)/O(n log n) prepro
DS: Segment Tree	binary tree built on <b>top of integer array</b><br><br>solve the <b>dynamic Range Min/Max/Sum Query</b> with <b>Range Update Query</b><br><br>all in <b>O(log N)</b><br><br><b>3</b> types of trees: RMinQ/RMaxQ/RSumQ<br><br>built in O(n)
DS: Difference between Interval/Segment/Binary Index Tree	- Interval: from intervals, dynamic, find intersection with query interval<br><br>- Segment Tree: from int array, solve dynamic Range Min/Max/Sum with Range Update<br><br>- Binary Indexed Tree (=Fenwick): for array, solve dynamic Range Sum only, but simpler than Segment Tree
DS: Binary Indexed Tree (BIT, Fenwick)	from a <b>prefix sum table</b><br><b>dynamic query</b> and <b>update</b><br>easier to code than SegmentTree<br><br>Variants: with Point or Range query, with Point or Range update<br><br>Build: O(n), Queries: O(log n)
Lang: C++ API (6)	- it find(b, e, x)<br>- int count(b, e, x)<br>- it nth_element(b, b+k, e)<br>- it lower_bound(b, e, x)<br>= first >= x<br>- bool next_permutation(b, e)<br>- void reverse(b, e)
Array/subasum: find subarray of size >=k with maximum average	<b>Binary Search</b> on max <b>avg value</b><br><br>Check: is there a subarray of size k+ with average >= X<br>substract X from each cell, find subarray with >= sum<br><br>O(??)
Prob/meth: problem solving steps	<b>CEEBEMTT</b><br><b>C</b>larify<br><b>E</b>xample<br><b>E</b>dge cases<br><b>B</b>rute force<br><b>E</b>fficient solution<br><b>M</b>anual run<br><b>T</b>rade-offs<br><b>T</b>ests
Combinatorics: next lexicographic permutation	find leftmost position i such that subarray to its right is decreasing sorted<br><br>find in subarray the smallest number A(j) >= A(i)<br><br>swap A(j) and A(i)<br><br>reverse subarray to make it increasing sorted
SD primitives: 3 weak consistency models + strong	<b>eventual</b>: after some time all replicas agree<br><br><b>client-centric/session</b>: ex. client will never see older value, read-my-writes<br><br><b>causal</b>: strongest<br><br><b>strong</b>: value of latest put
Lang: how is set/map implemented in C++	<b>Red-Black</b> trees
Lang: DS when duplicates	multiset<br><br>does multimap exist?
Prob/search: f real-valued. search x s.t. a. f(x) = 0, and b. f(x) maximum if f unimodal	a. <b>binary search</b><br><br>b. <b>ternary</b> search<br>split in <b>3</b> and evaluates <b>2 points</b>
SD: Pregel/Giraph, how it works	distributed <b>graph processing</b><br>at each <b>iteration</b>:<br><b>vertex</b> receives <b>messages</b> sent by other vertices at previous step</b> to other<br><br>performs computation<br>can <b>update</b> its vertex <b>value</b> and outgoing edges values<br>can <b>send</b> messages<br><br>like a mapper can send to reducer in MR
DS:<br>Adv/Disadvantage of BST vs. HashTable	<b>BST</b> can enumerate in <b>key order</b> (range search, prev/next)<br><br>HashTable simpler when <b>duplicate keys</b><br><br>HashTable better average perf O(1)<br>BST better worse case perf O(n log n)
DS: Too large for memory (5)	D&C<br>External merge sort<br>Split in steps: ex. LSB/MSB<br>MapReduce<br>Graph: processing with iterations Pregel
Array: techniques (5)	<b>two-p</b>ointers<br>sliding <b>window</b><br><b>sorted stack</b>/queue/dequeue<br><b>BS</b> in efficient array<br><b>D&C mergesort</b>-like when <b>order</b> matters
Array/matrix: techniques (2)	- iterate on row(s) and <b>reduce</b> to <b>1D</b><br>- 2D/memoized DP