Array/prob: trapping rain water (3)<br>n vertical lines	- DP with <b>2 precomp arrays</b>: maxHeightFrom[i], maxHeightUntil[i], take <b>min[i]</b>=intersection O(n)<br><br>- <b>stack</b><br><br>- <b>2 pointers, from start and end</b><br><b>move smaller one</b> at each step<br><br>O(n)|O(1)
Array: largest rectangle under histogram (2)	- D&C n log n<br><br>- <b>stack</b> O(n)<br>for each bar, we want size when it is highest bar, so <b>triangle ^ pattern</b><br><br>use <b>stack of increasing heights</b> indices<br>at bar i, if top of stack bigger, pop: i=right <b>boundary excluded</b>, top=height, belowTop=left <b>boundary excluded</b>
Array: skyline (2)	 - 1. <b>PriorityQueue</b> + <b>BST</b> (TODO)<br><br>- 2. <b>divide and conquer</b><br>like merge sort<br><br>- divide in <b>2 equal sets</b> (no order or sort)<br>- compute skyline for each<br>- <b>merge</b>: <b>iterate</b> on both<br><br>O(n log n)
Array: trapping rain water, largest rectangle under histogram, skyline<br>+ complex	- rain: <b>2-pointers left/right</b> O(n)<br><br>- histogram: <b>incr. stack</b> triangle <b>^</b> O(n)<br><br>skyline: <b>D&C mergesort</b> O(n log n)
Graph: shortest path visiting all nodes	<b>BFS</b> with <b>bitmask</b> for visited nodes in queue item
DS/prob: check if item is in known set	<b>Bloom filter</b> if no space for hash table<br><br><b>10 bits</b> per item for <b>1%</b> false positive
Graph/paths: number of paths from src to dest with k edges (2)	1. DP <b>numPaths[src][dest][edges]</b><br>O(k V^3)<br><br>2. Divide and Conquer <b>matrix power</b> G^k<br>O(log k) matrix power<br>total: O(V^3 log k)
Graph/paths: shortest path with exactly k edges in a directed and weighted graph (2)	<b>DP dist[s][t][k]</b><br>fill with k increasing<br><br>O(V^3 k)<br><br>- APSP(k): G^k but with <b>min</b> operator<br>O(n^3 log k)
