Array/window: sliding window median	would like to use 2 heaps as in continuous medians, <b>but</b> we need to <b>remove</b><br><br>use <b>BST</b>(s) instead, deal with <b>duplicates</b><br><br>or use C++ <b>multiset</b><br><br>O(n log k)
Array/pair: maximum gap<br>max diff of two consecutives values if array was sorted	- <b>bucket sort</b> but keep only min and max in bucket<br><br>buckets must be <b>big enough</b> so that <b>one is empty</b><br>will give max distance<br><br>- <b>scan buckets</b> to find max gap<br><br>O(n)
Algo: by complexity O(1) (2), log n (3), n (6)	- <b>constant</b>: HashTable, Union-Find<br><br>- <b>log n</b>: binary search, tree/BST, heap (log k)<br><br>n: heapify, quickselect, distribution sort, 2-pointers, Kadane, BFS/DFS
Algo: by complexity n log n (5), n^2 (2), n^3 (2)	- <b>n log n</b>: sort, divide and conquer, mergesort-like, LIS, convex hull<br><br><b>n^2</b>: LCS/edit, Dijkstra V^2<br><br><b>n^3</b>: Bellman-Ford EV, Floyd-Warshall V^3
SD components/store: Raid 0, 1, 5	- Raid <b>0</b>: <b>shard</b> (stripe) data on disks. Better <b>perf</b>.<br><br>- Raid <b>1</b>: <b>replicas</b>. N-1 <b>resiliency</b><br><br>- Raid <b>5</b>: 3+ disks + <b>parity</b> disk (spread)<br>supports 1 disk down
SD low-level: virtual memory (def, done by, uses (2))	<b>maps</b> addresses used by program (<b>virtual</b>) into <b>physical</b> addresses in memory<br><br>mem appears as a <b>contiguous</b> address space<br><br><b>MMU</b> translates addresses with <b>Page tables</b><br><br>Allows swapping
SD/pattern: how to reduce <b>tail latencies</b>	<b>Backup requests</b><br><br>send <b>second request</b> to <b>other</b> server when first answer is late
Array/Matrix: largest all-1 + sign, square, rectangle	+ sign: precompute 4D<br><br>- square: precompute 2D<br><br>- rectangle: precomp 1D (up)<br>n (row) * O(m) largestRectangleUnderHistogram with stack
Array/Matrix sum: max sum square, rectangle	- square: standard O(nm) DP<br><br>- rectangle: n^2 (rows) * O(n) Kadane