Array/window: sliding window median	would like to use 2 heaps as in continuous medians, <b>but</b> we need to <b>remove</b><br><br>use <b>BST</b>(s) instead, deal with <b>duplicates</b><br><br>or use C++ <b>multiset</b><br><br>O(n log k)
Array/pair: max diff of two consecutives values if array was sorted	- <b>bucket sort</b> but keep only min and max in bucket<br><br>buckets must be <b>big enough</b> so that <b>one is empty</b><br>will give max distance<br><br>- <b>then scan buckets</b> to find max gap<br><br>O(n)
Algo: by complexity O(1) (2), log n (3), n (7)	- <b>constant</b>: HashTable, Union-Find<br><br>- <b>log n</b>: binary search, tree/BST, heap (log k)<br><br>n: heapify, quickselect, distribution sort, 2-pointers, Kadane, BFS/DFS, monotonic stack/queue
Algo: by complexity n log n (5), n^2 (2), n^3 (2)	- <b>n log n</b>: sort, divide and conquer, mergesort-like, LIS, convex hull<br><br><b>n^2</b>: LCS/edit, Dijkstra V^2<br><br><b>n^3</b>: Bellman-Ford EV, Floyd-Warshall V^3
SD components/store: Raid 0, 1, 5	- Raid <b>0</b>: <b>shard</b> (stripe) data on disks. Better <b>perf</b>.<br><br>- Raid <b>1</b>: <b>replicas</b>. N-1 <b>resiliency</b><br><br>- Raid <b>5</b>: 3+ disks + <b>parity</b> disk (spread)<br>supports 1 disk down
SD low-level: virtual memory (def, done by, uses (2))	<b>maps</b> addresses used by program (<b>virtual</b>) into <b>physical</b> addresses in memory<br><br>mem appears as a <b>contiguous</b> address space<br><br><b>MMU</b> translates addresses with <b>Page tables</b><br><br>Allows swapping
SD/pattern: how to reduce <b>tail latencies</b>	<b>Backup requests</b><br><br>send <b>second request</b> to <b>other</b> server when first answer is late
Array/Matrix: largest all-1 + sign, square, rectangle	+ sign: precompute 4D<br><br>- square: natural O(nm) DP<br><br>- rectangle: precomp 1D (up)<br>n (row) * O(m) largestRectangleUnderHistogram with stack
Array/Matrix sum: max sum square, rectangle	- square: difficult, except if fixed size<br><br>- rectangle: n^2 (rows) * O(n) Kadane
Array/subasum: smallest subarray with sum >= k (2)	- <b>Positive</b> numbers:<br><b>sliding window/two-pointers</b>: accumulate until sum greater than x, pop starting elements<br>O(n)<br><br>- <b>with negative numbers</b>: <br>monotonous stack/deque<br>O(n)
Array/subasum: subarray sum (max, shortest >= k, max no more than k)	- max: Kadane O(n)<br><br>- positive: 2p sliding window O(n)<br>general: monotonic stack<br><br>- max <= k: O(n log n) using <b>BST upper_bound</b>
Array/prob: trapping rain water (3)<br>n vertical lines	- DP with <b>2 precomp arrays</b>: maxHeightFrom[i], maxHeightUntil[i], take <b>min[i]</b>=intersection O(n)<br><br>- <b>stack</b><br><br>- <b>2 pointers, from start and end</b><br><b>move smaller one</b> at each step<br><br>O(n)|O(1)
Array: largest rectangle under histogram (2)	- D&C n log n<br><br>- <b>stack</b> O(n)<br>for each bar, we want size when it is highest bar, so <b>triangle ^ pattern</b><br><br>use <b>stack of increasing heights</b> indices<br>at bar i, if top of stack bigger, pop: i=right <b>boundary excluded</b>, top=height, belowTop=left <b>boundary excluded</b>
Array: skyline (2)	 - 1. <b>PriorityQueue</b> + <b>BST</b> (TODO)<br><br>- 2. <b>divide and conquer</b><br>like merge sort<br><br>- divide in <b>2 equal sets</b> (no order or sort)<br>- compute skyline for each<br>- <b>merge</b>: <b>iterate</b> on both<br><br>O(n log n)
Array: trapping rain water, largest rectangle under histogram, skyline<br>+ complex	- rain: <b>2-pointers left/right</b> O(n)<br><br>- histogram: <b>incr. stack</b> triangle <b>^</b> O(n)<br><br>skyline: <b>D&C mergesort</b> O(n log n)
Graph: shortest path visiting all nodes	<b>BFS</b> with <b>bitmask</b> for visited nodes in queue item
DS/prob: check if item is in known set	<b>Bloom filter</b> if no space for hash table<br><br><b>10 bits</b> per item for <b>1%</b> false positive
Graph/paths: number of paths from src to dest with k edges (2)	1. DP <b>numPaths[src][dest][edges]</b><br>O(k V^3)<br><br>2. Divide and Conquer <b>matrix power</b> G^k<br>O(log k) matrix power<br>total: O(V^3 log k)
Graph/paths: shortest path with exactly k edges in a directed and weighted graph (2)	<b>DP dist[s][t][k]</b><br>fill with k increasing<br><br>O(V^3 k)<br><br>- APSP(k): G^k but with <b>min</b> operator<br>O(n^3 log k)
