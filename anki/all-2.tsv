Array: Range Minimum Query RMQ (static, dynamic)	1. <b>static</b>:<br><b>preprocess</b> trade-offs: ex. full lookup<br><br><b>Sqrt decomposition</b> 1D trade-off<br><br><b>Sparse table</b><br>O(1) query, O(n log n)/O(n log n) prepro<br><br>2. <b>dynamic</b>: <b>Segment Tree</b><br>O(log n) query/update 
Array: Range Sum Query 1D (static, dynamic) (2)	<b>static</b>: easy, just prefix sum<br><br><b>dynamic</b>:<br>- BIT (=Fenwick)<br>- SegmentTree
Array: from 3 sorted arrays, find i, j, k s.t. d(i,j,k)=max(|A(i)-B(j)|, ...) is minimum	<b>1 pointer in each</b><br><b>move 1</b> (min) at each step<br><br>like intersection of sorted arrays<br><br>record minimum<br><br>O(len A + len B + ..)
Array: largest rectangle under histogram (2)	- D&C n log n<br><br>- <b>stack</b> O(n)<br>for each bar, we want size when it is highest bar, so <b>triangle ^ pattern</b><br><br>use <b>stack of increasing heights</b> indices<br>at bar i, if top of stack bigger, pop: i=right <b>boundary excluded</b>, top=height, belowTop=left <b>boundary excluded</b>
Array: skyline (2)	 - 1. <b>sort + PriorityQueue</b><br><br>- 2. <b>divide and conquer</b><br>like merge sort<br><br>- divide in <b>2 equal sets</b> (no order or sort)<br>- compute skyline for each<br>- <b>merge</b>: <b>iterate</b> on both (tricky)<br><br>O(n log n)
Array: techniques (5)	<b>two-p</b>ointers<br>sliding <b>window</b><br><b>sorted stack</b>/queue/dequeue<br><b>BS</b> in efficient array<br><b>D&C mergesort</b>-like when <b>order</b> matters
Array: trapping rain water, largest rectangle under histogram, skyline<br>+ complex	- rain: <b>2-pointers left/right</b> O(n)<br><br>- histogram: <b>incr. stack</b> triangle <b>^</b> O(n)<br><br>skyline: <b>sort + PQ; or D&C mergesort</b> O(n log n)
Binary Search: find <b>first</b> element (2)	- tweak binary search<br><br>- or set <b>currentBest variable</b> and continue
Combinatorics: compute<br>subsets of a set<br>permutations of a set	subsets: recursive, or iterative (bitmask)<br><br>permutations: recursive
Combinatorics: next lexicographic permutation	find leftmost position i such that subarray to its right is decreasing sorted<br><br>find in subarray the smallest number A(j) >= A(i)<br><br>swap A(j) and A(i)<br><br>reverse subarray to make it increasing sorted
DS HashTable: hash table strategies (3)	chaining: <b>linked lists</b><br><br><b>open adressing</b>: next position<br><br><b>double hashing: h()+i*g(), less clustering</b>
DS Heap: specialized heaps (2)	when <b>limited set</b> of keys,<br><br>or <b>monotonic</b> input
DS Priority Queue: 6 example use of a priority queue	- continous top k<br>- k-way merge<br>- continous median<br>- sort when only k indices away<br>- heapsort/tree sort<br>- Dijkstra/Prim
DS Priority Queue: monotonic priority queue<br>def, examples	min monotonic: inserted elements have <b>higher prio than min</b> of heap<br><br>Dijkstra, sweep line<br><br>can <b>optimize bucket queue</b>
DS PriorityQueue <br>implementations (2) and stack (2)	- priority queue: <b>heap</b>, <b>BST</b><br><br>- stack: <b>linked list</b><br>or <b>array</b><br>(needs resizing, so amortized)
DS PriorityQueue bucket queue<br>def, use case	<b>priority queue</b> when <b>restricted prio range</b><br>{0, 1, ..., C - 1}<br><br><b>array</b> of <b>C linked lists</b><br><br>to find min, search non-empty list from i=0: O(C)<br>(optimizations possible)<br><br>insert: O(1)
DS algo: complexity analysis (4)	- <b>flatten loops</b> for global count<br><br>- <b>Memoized</b>: NbDiffSubProblems * TimePerSubProblem<br><br>- <b>Recursion</b> with formula<br><br>- <b>Amortization</b>
DS/prob: HyperLogLog, def, use	<b>approximate count-distinct</b> with O(1) mem<br>hash stream entries and only record the <b>longest leading zero seq length</b><br><br>Improve with buckets, outliers and averaging<br><br>Use in ApproxCountDistinct in DBs.
DS/prob: check if item is in known set, space needed	<b>Bloom filter</b> if no space for hash table<br><br><b>10 bits</b> per item for <b>1%</b> false positive
DS/prob: countâ€“min sketch, def, use	probabilistic data structure: <b>frequency table of events</b> in a <b>stream</b> of data<br><br>same as <b>counting Bloom Filter</b><br><br><b>Table</b>: row=hash function, column: bucket (space of hash), entry: integer<br><br>ex: count views for many many videos
DS/prob: probabilistic data structures (3)	<b>Bloom</b> filter: set<br><br><b>Count-Min sketch</b>: count by type<br><br><b>HyperLogLog</b>: count
DS/tree: tournament tree, def, use	complete binary tree<br>2 case: <b>winner</b>, <b>loser</b> tree<br><br>player=leaves<br>min/max winner/loser<br><br>apps: sorting, first-fit bin packing, k-way merge
DS/tree: treap, def, use	<b>BST</b> and <b>heap</b><br><br>node is <b>pair</b> (x, y)<br>x: real key, in the <b>BST</b><br>y: random key in the heap (<b>priority</b>)<br><br>random prio: will probably <b>make BST balanced</b>
DS: <b>Interval tree</b>, search algo	red black tree<br>each node is interval<br><br>node contains:<br>1. start of interval=sort key<br>2. end of interval<br>3. maxEnd of intervals in subtree<br><br>search for intersection O(h):<br>go in right or left (bit tricky proof)
DS: Binary Indexed Tree (BIT, Fenwick) + complex	from a <b>prefix sum table</b><br><b>dynamic query</b> and <b>update</b><br>easier to code than SegmentTree<br><br>Variants: with Point or Range query, with Point or Range update<br><br>Build: O(n), Queries: O(log n)
DS: Difference between Interval/Segment/Binary Index Tree	- Interval: from intervals, dynamic, find intersection with query interval<br><br>- Segment Tree: from int array, solve dynamic Range Min/Max/Sum with Range Update<br><br>- Binary Indexed Tree (=Fenwick): for array, solve dynamic Range Sum only, but simpler than Segment Tree
DS: LFU cache<br>implementation	<b>3 hash maps</b>, one with linked list as values
DS: Segment Tree, complex	binary tree built on <b>top of integer array</b><br><br>solve the <b>dynamic Range Min/Max/Sum Query</b> with <b>Range Update Query</b><br><br>all in <b>O(log N)</b><br><br><b>3</b> types of trees: RMinQ/RMaxQ/RSumQ<br><br>built in O(n)
DS: Sparse Table, application, def, complex	<b>static</b> Range Minimum Query<br>easier than <b>Segment Tree</b> when static<br><br>get O(1)?? query but without full O(n^2) lookup<br><br>T[i][k]: minimum of <b>A[i][i+2^k]</b><br><br>build <b>bottom-up</b> DP<br><br>O(1) query, O(n log n)/O(n log n) prepro
DS: Too large for memory (5)	D&C<br>External merge sort<br>Split in steps: ex. LSB/MSB<br>MapReduce<br>Graph: processing with iterations Pregel
DS: implement LRU cache	= <b>DLL Queue + HashTable</b>: <br><br>queue: doubly linked list (size: cache size). MRU at front.<br><br>hash: address of the queue node as value
DS: skip list<br>- definition<br>- complexities<br>- used in	linked list for binary search<br>layers of sorted linked lists (<b>express lanes</b>)<br>p = 1/2 or 1/4, proba for element to be also in layer below<br><br><b>O(log n)</b> average for search/insert/delete, O(n) average space<br>used in LevelDB MemTable
Geo DS: quad-tree	2D hierarchical partition in quadrants<br><br><b>4</b> children by node<br>split when max capacity reached.
Geo: convex-hull algorithm, complex (3)	wrapping O(nh)<br><br>sweep line O(n log n)<br><br>divide and conquer O(n log n)
Geo: horizontal/vertical line intersections	<b>sweep</b> 3 events: start/end of horiz, vertical<br><br>keep set of <b>active horiz lines</b> in <b>BST</b><br><br>for a vertical: <b>range search</b> in BST to find intersections
Geo: k-d tree<br>definition<br>4 complexities	split in 1 dimension at each node (median of coordinate to get balance)<br><br>search/insert/delete O(log n) average<br>Space: O(n)
Geo: line through most points	<b>hash</b><br>H[line] = list of points<br><br>for each pair, add entry in H<br><br>tricky hash because floats<br>use rationals
Graph/co: Find connected components of an undirected graph (2)	<b>- BFS/DFS</b> O(V + E), <br><br>- <b>or</b> process <b>edges</b>, <b>Union-Find</b> on vertices<br><br>If <b>dynamic</b> changes: <b>Union-Find</b>.
Graph/co: Strongly Connected Components<br>definition and algo name/cplx	subgraphs s.t. if every vertex is reachable from every other vertex<br><br>K: first DFS topological sort<br>second DFS in inverse graph collect SCC<br><br>T: only one pass<br>O(V + E)
Graph/co: transitive closure def, algo	= reachable[s][t] matrix<br><br><b>(if undirected: = easy connected-co)</b><br><br>directed (2):<br><br>1. DFS on each vertex to fill reachable[src][*]<br>O(V (V + E))<br><br>2. or <b>Floyd-Warshall-like</b> O(n^3)
Graph/cycle: Detect cycle in a graph<br>(dir/undir, complex) (2)	1. <b>Colorized DFS</b> (directed or not): look for <b>back-edge</b><br>undirected: <b>ignore edge to parent</b><br>O(V + E).<br><br>2. <b>Undirected only</b>: <b>Union-Find</b>:<br><b>loop on edges</b>, UF on vertices<br>O(E + V)
Graph/cycle: Eulerian cycle: def, exist/find algos	visit each edge<br><br>linear time O(E)<br>vs. Hamiltonian is NP-hard<br><br>check if exists: look at conditions on degree<br><br>find: O(E) exists (Fleury)
Graph/paths: 4 SSSP/APSP algs	- BFS<br>- Dijkstra: O(V^2) or less with heap. Greedy closest edge.<br><br>- Bellman-Ford: O(VE) OK with negative weights, no cycles. Relax all edges |V| times<br><br>- Floyd-Warshall: same as Bellman-Ford but all pairs. O(V^3)/O(V^2)
Graph/paths: longest path from vertex in weighted graph<br>+ DAG	NP-hard for general graph<br>naive Bruteforce E!<br><br>linear for DAG: toposort, then loop<br>O(V + E)
Graph/paths: number of paths from src to dest with k edges, complex (2)	1. DP <b>numPaths[src][dest][edges]</b><br>O(k V^3)<br><br>2. Divide and Conquer <b>matrix power</b> G^k<br>O(log k) matrix power<br>total: O(V^3 log k)
Graph/paths: print number of paths with no cycle between two nodes in a directed graph	<b>backtracking</b><br><br>set/unset visited nodes
Graph/paths: shortest path with a max delay constraint (edges have weight and delay)	<b>memoized DP</b><br>dp[destinationVertex,withDelay]<br><br>O(E maxDelay)
Graph/paths: shortest path with exactly k edges in a directed and weighted graph (2)	<b>DP dist[s][t][k]</b><br>fill with k increasing<br><br>O(V^3 k)<br><br>- APSP(k): G^k but with <b>min</b> operator<br>O(n^3 log k)
Graph/prob: clique<br>definition, 2 problems and solutions	complete subgraph<br>maximum clique: largest in the graph (difficult in general, heuristics)<br><br>maximal: can not be extended (greedy)
Graph/prob: color graph with k colors, algo/complex	<b>backtracking</b><br><br>O(k^V)?
