Array: largest rectangle under histogram	O(n) left to right with stack
DS: B-Tree	self balancing tree, <br>not binary, <br>good for r/w to external memory (DB FS)
DS: external merge sort	sort chunck & write to disk, load chunk of chuck and merge-write
DS: good sort for a linked list	good: merge sort<br><br>possible but more difficult?: quick sort
DS: range minimum or range sum	Segment Tree
DS: total storage for YT/FB	500 PB
Graph: maximum clique algorithm	difficult, there are heuristics
Graph: 4 shortests path algs	- BFS<br>- Dijkstra: O(V^2) or less with heap. Greedy closest edge.<br><br>- Bellman-Ford: O(VE) OK with negative weights, no cycles. Relax all edges |V| times<br><br>- Floyd-Warshall: same as Bellman-Ford but all pairs. O(V^3)/O(V^2)
Lang: pure virtual function	has to be implemented by a class that is not abstract
Misc: NP-complete problems	SAT, knapsack, traveling salesman
SD: 2 types of failover	active-passive (master-slave)<br><br>active-active (master-master)
SD: ACID	atomicity, consistency, isolation, durability
SD: drawback of DNS load balancing	results are cached by intermediate servers, so not responsive when change
SD: in MySQL master-slave, how to ensure read-after-write has most recent value	read from Master
SD: mechanism for asynchronicity	queues
SD: MySQL index based on which data structure in general	B-tree (or B+ ?)
SD: tunable consistency	from "writes never fail" to <br><br>"block for all replicas to be readable" with quorum levels
SD: types of replication	asynchronous: MySQL default, <br>synchronous: two phase commit MySQL-cluster default
SD: how many queries per second for a MySQL DB server	no answer, <br>depends on query/HW. 1K QPS
SD: how many YT videos watched every day	5B
SD: BigTable scale	thousands of machines, <br>TB memory, <br>PB disk, <br>millions of r/w per second
Tree: balanced BST: complexity, 4 examples	Search/insert/delete O(log n)<br><br>AVL<br>Red-black<br>B-tree<br>2-3 tree
Tree: k-d tree	split in 1 dimension at each node (median of coordinate to get balance)
Tree: quad-tree 2D partition	 each node has 4 children.<br> Split when max capacity reached.
SD: CAP theorem.<br>2 possible combinations	Consistency: every read gets most recent write or error<br>Availability: every request gets response but no guaranties<br>Network Partition Tolerance: continues even if network failure<br><br>CP or AP
SD: consistency patterns	weak: best effort<br>eventual: asynchronous replication<br>strong: after a write, reads will see it. RDBMS.
SD: techniques to scale RDBMS	master-slave replication, master-master replication, federation, sharding, denormalization, and SQL tuning.
SD: disadvantage of master-master replication	loosely consistent (violating ACID) or big write latency due to synchronization
SD: 4 cache strategies	cache aside: app does everything<br>write-through: cache interacts with DB<br>write-behind/back: app writes to cache and async write to DB<br>refresh ahead: auto refresh by cache