Array: largest rectangle under histogram	O(n) left to right with stack
DS: good sort for a linked list	good: merge sort<br><br>possible but more difficult?: quick sort
DS: range minimum or range sum	Segment Tree
Graph: maximum clique algorithm	difficult, there are heuristics
Graph: 4 shortests path algs	- BFS<br>- Dijkstra: O(V^2) or less with heap. Greedy closest edge.<br><br>- Bellman-Ford: O(VE) OK with negative weights, no cycles. Relax all edges |V| times<br><br>- Floyd-Warshall: same as Bellman-Ford but all pairs. O(V^3)/O(V^2)
SD: 2 types of failover	active-passive (master-slave)<br><br>active-active (master-master)
SD: drawback of DNS load balancing	results are cached by intermediate servers, so not responsive when change
SD: in MySQL master-slave, how to ensure read-after-write has most recent value	read from Master
SD: BigTable scale	thousands of machines, <br>TB memory, <br>PB disk, <br>millions of r/w per second
Tree: balanced BST: complexity, 4 examples	Search/insert/delete O(log n)<br><br>AVL<br>Red-black<br>B-tree<br>2-3 tree
SD: CAP theorem.<br>2 possible combinations	Consistency: every read gets most recent write or error<br>Availability: every request gets response but no guaranties<br>Network Partition Tolerance: continues even if network failure<br><br>CP or AP
SD: consistency patterns	weak: best effort<br>eventual: asynchronous replication<br>strong: after a write, reads will see it. RDBMS.
SD: techniques to scale RDBMS	master-slave replication<br>master-master replication<br>federation<br>shardin<br>denormalization<br>and SQL tuning
SD: disadvantage of master-master replication	loosely consistent (violating ACID) or big write latency due to synchronization
SD: 4 cache strategies	cache aside: app does everything<br>write-through: cache interacts with DB<br>write-behind/back: app writes to cache and async write to DB<br>refresh ahead: auto refresh by cache
SD: advantage of columnar storage	if usage pattern is to read whole table<br>but only some columns<br>don't read unused columns
SD: WAL	write-ahead logging<br>first log actions to be done to permanent storage<br><br>then do the actions<br><br>gives durability and atomicity even if crash
SD: MySQL storage engine	InnoDB: row locking so better concurrency<br><br>MyISAM: old, maybe table locking better when lots of reads
SD: replication modes of MySQL	statement-based ("insert ...") = logical<br>row-based: result of the statement = physical<br><br>or a mix
SD: use cases of UDP	best effort delivery for voice/video streaming, games
SD: memcached perf	on machine with good network, 200k/s easily<br>latency: 1ms