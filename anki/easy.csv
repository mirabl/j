LinkedList: reverse a linked list;iterative
LinkedList: find where 2 linked list merge;2 pointers 
LinkedList: cycle length of a linked list;2 pointers 
DS: implement a queue using two stacks;empty first stack into second stack
Tree: from sorted array, create BST with minimal height;take middle of array then recursive
Bit: test if a number is a power of two;((n & (n-1)) == 0)
Search: find element in a sorted rotated array;double BS: find the frontier, BS on left or right part
Search: find element in row-and-column-sorted matrix;start from NE corner
print valid n-parentheses;try a character, recurse if allowed
DS: merge k sorted arrays;heap
Sort: insertion sort;insert A[i] in A[0]...A[i-1]
Sort: selection sort;select min put it at A[i=0], i++
C++: stack API;#include <stack>, push(), pop(), top()
Graph/Tree: two ways to do BFS level order of tree;with NULL marker, or empty queue at each step
LinkedList: last-M-th element of a linked list;2 pointers, one M ahead
LinkedList: middle of a linked list;2 pointers
reverse array in place;swap elements, maybe middle 
LinkedList: is a linked list a palindrome?;reverse second half, check (and restore)
Tree: iterative in-order traversal of binary tree;stack and curnode pointer
Stack: sort a stack;using a second stack, or recursively
String: determine if a string has only unique characters (with and without memory);use a set, or sort the string
Combinatorics: compute subsets of a set;recursive, iterative
Combinatorics: compute all permutations of a string;recursive
LinkedList: Sort a linked list;use merge sort
Graph: is there a route between two nodes of a directed graph;careful with cycles
Math: number of trailing zeroes in a factorial;powers of 2, 5
Array: rotate image by 90 degrees;ring by ring, or reverse up to down (r2l) and transpose
Sort: bubble sort;swap pairs to put max at i=end of array, i--
Sort: merge sort;merge sorted subarrays with auxiliary array (allocate once)
C++: queue API;#include <queue>, push(), pop(), front()
String: Edit Distance;DP O(mn)
Heap: search a key in a heap;difficult O(n)
Graph: shortest path when edges have no weight;BFS
DS: extract minimum with streaming data;use heap
LinkedList: Select random node from linked list;method1: count nodes first. method2:reservoir sampling O(n) one pass.
2D Array: Boggle (Find all possible words in a board of characters);DFS from every start cell, mark visited cells. Complexity? Better solution with Tree.
Tree: Check if binary tree is full (not complete);recursive O(n)
Sort: sort when element are nearly sorted (2 ways);heapsort, insertion sort
Sort: name of sort which preserves original order for same key values;stable sort
MergeSort: best and worst case;always O(n log n)/O(n) aux
Selection sort: best and worst case;no difference, always O(n^2)/O(1) auxiliary
Insertion sort: best and worst case;best: sorted O(n)/O(1) aux, worst: reverse sorted O(n^2)/O(1) aux
Heap: complexity of insert/extract-min;O(log n)
QuickSort: space complexity of quicksort;O(log n) in-place partitioning
QuickSort: best and worst case of QuickSort;best: pivot splits array in half each time O(n log n)/O(log n), worst: pivot is min (or max), O(n^2)/O(log n)
Graph: what is a bipartite graph?;vertices are split in to sets, no edges within a set
Sort: sort when limited range of keys;counting sort O(n + k)/O(n + k), bucket sort O(n + k)/O(nk), radix sort O(w n)/O(w + n)
Coin Game: coins in a row, pick one;DP F(from i-th coin to j-th coin) = max(. + min(), . + min()), O(n^2)
String: Find the smallest window in a string containing all characters of another string;sliding window O(n)|O(n)
Array: is subsequence;iterate, not need for dp
QuickSort: algorithm;(randomize first), select pivot, partition, sort left and right partition
LinkedList: insertion in linked list tip;use dummy first node
C++: vector in C++ access/remove last element;back()/pop_back()
Stack: implement stack with O(1) min;push (x, min) when pushing x, or use second stack
Heap: algo for insert;add element to bottom right, bubble up O(log n)
Heap: algo for extract-min;save top element, put bottom right at top, bubble down O(log n)
Quicksort: pivot choosing methods? (3);first, random, median of random 3
Array: Longest Common Subsequence;DP O(nm)
Array: Longest Increasing Subsequence;DP O(n^2). also possible in O(n log n) with active lists and binary search
Minimum difference partition;DP CanMakeSum[i][T], T <= S/2, O(n S)
Subset sum: a subset of array sums to T;DP CanMakeSum[i][T], O(n S)
0-1 Knapsack: max weight, items with values and weights, maximize value;DP Best[i][w] O(n W)
Tree: Maximum path sum in a binary tree;recursive, only left, only right, both. O(n)
Array: Next Greater element in an array;using a stack, O(n)/O(n)
Tree: Bottom view of binary tree;BFS with (ordered) map: M[x-coordinate] = value. O(n)/O(n)
Longest Palindromic Substring;for each position, find longest even and odd length substring with this center O(n^2)|O(1) // DP bottom-up with length-0 length-1 -2 ... substrings O(n^2)|O(1) // O(n) difficult algorithm exists Manacher.
MergeSort: space complexity;O(n) auxiliary
String: substring search;naive O(n*m) // robin-karp rolling hash O(n + m) // advanced O(n)
Merge intervals;sort by start, one pass O(nlog n)|O(n)
Array: 3Sum  Find all unique triplets in the array which gives the sum of zero;sort, loop for first element and then 2sum sweep, avoid duplicates by avoiding duplicate first element O(n^2)|O(1)
Array: 2sum: Given an array of integers, return indices of the two numbers such that they add up to a specific target.;same element twice? Use hash table O(n)|O(n), sort+two pointers O(n log n)|O(1), sort+BS O(n log n)|O(1)
String: Longest Substring Without Repeating Characters;Window. left and right pointers, hash set for characters in the substring, move either left or right O(n)|O(n) // traverse left to right, maintaining longest valid substring ending at this position, use map<char,position> to know where current character appeared last O(n)|O(n)
Container With Most Water;two pointers, from start and end, reduce width and stop only when height increases, O(n)|O(1)
Graph: Shortest Path from every vertex to every other vertex **Floyd Warshall**;O(V^3)/O(V^2)
Graph: Complexity of shortest Path from source to all vertices **Dijkstra** ;Time: O(V^2). Better complexity with Fibonacci heap.
Graph: Minimum Spanning tree **Prim**: algorithm and complexity;greedy vertices: add new vertex of minimum distance to partial tree. O(V^2), can be reduced with binary heap.
Graph: Minimum Spanning tree **Kruskal**: algorithm and complexity;sort edges by weight, (take min edge, check if it introduces a cycle in the partial tree, discard or add). Cycle detection with union-find. O(E log V) = O(E log E)
Graph: A*: idea, difference with dijkstra;choose vertex which score minimizing distance processed vertices and _distance to target_
Heapify: algorithm and complexity;O(n) when heapifying from the lower levels to the upper levels, "sinkdown" roots of subtrees
Array: Count triplets with sum smaller than a given value in O(n^2);sort, loop for first element, use two-pointer-sum<br>O(n^2)|O(1) aux
Array: find subarray with maximum sum;one pass, at each position either extend or start new subarray O(n)|O(1)
Max number of intersecting intervals;sort events: enter and exist of intervals. O(n log n)|O(n) aux
combination sum: Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T., same number can be repeated;backtracking (or DP)
Graph: Bridges in a Graph;Naive: remove edge, see if graph is still connected: O(E (V + E)). Better algorithm based on DFS O(V + E) exists.
Array: Reverse an array without affecting special characters;O(n) one pass, in-place: two pointers at start and end<br>swap or skip and meet in the middle<br>O(n)|O(1) aux
Array: find the median of non-sorted array;QuickSelect O(n)
Array: find the majority element;Voting algorithm O(n)
Array: Stock Buy Sell to Maximize Profit (buy & sell multiple times);1. Find the local minima and store it as starting index. If not exists, return.<br>2. Find the local maxima. and store it as ending index. If we reach the end, set the end as ending index.<br>3. Update the solution (Increment count of buy sell pairs)<br>4. Repeat the above steps if end is not reached.
Array: Convert array into Zig-Zag fashion: distinct element or not cases;distinct O(n)|O(1) aux bubble sort-like swap<br>not distinct QuickSelect to find median, partition O(n)

LinkedList: Detect beginning of a cycle;method1: count cycle length, count first segment length. method2: smarter, TODO. O(n)
Graph: Topological sort of DAG (2); 1. DFS with stack: push to stack after calling DFS on adjacent vertices (so they are on the stack below). O(V + E). 2.  BFS-style algorithm: find vertices of in-degree 0, process, remove edges to other vertices, repeat
Graph: Complexity of Breadth First Traversal for a Graph;O(V + E) if adjacency list, O(V^2) if adjacency matrix/O(V)
Graph: Complexity of Depth First Traversal for a Graph;time: O(V + E) if adjacency list, O(V^2) if adjacency matrix/O(V) 
String: Reverse words in a sentence;1. Word by word from the end. 2. reverse whole string char-by-char, reverse within each word
Union-find: naive + 2 optimizations;naive: attach root of x to root of y. Union by rank: attach smaller tree to larger. Path compression: when find is used, nodes on the path to root point to the root (recursive).
Union-find complexity with optimization;amortized O(1) in time |O(n) space.
Sudoku Solver;Backtracking. Only check if one value is already in a row/col/square.
Tree: Check if a binary tree is subtree of another binary tree;Naive O(n^2), O(n): inorder and preorder of subtree must be substrings of big tree
Array: Smallest subarray with sum greater than a given value;Sliding window: keep adding array elements while current sum is smaller than x<br>If current sum becomes greater than x, update min length, remove starting elements
Array: Rotate an array;1. With a temp array of size K. 2. With cycles (compute gcd)
Tree: Connect same level siblings;BFS level order
String: Regex matching;Recursive, DP. With offset going from left to right.
Tree: Print tree perimeter (border);print left boundary without leaf, print leaves, print right in reverse (recursive)
Graph: Find connected components of a graph;BFS/DFS O(V + E), keep track of components with Union-Find.
Graph: Detect cycle in a graph;Colorized DFS look for back-edge O(V + E). Also possible with Union-Find: loop on edges, union-find on vertices O(E)?
SD: RAM R/W speed;10 GB/s
SD: SSD R/W speed;500 MB/s
SD: HDD R/W speed;100 MB/s
SD: RAM latency;100 ns
SD: SSD latency;0.1 ms
SD: HDD latency;10 ms, disk seek
Array: Find maximum in sliding window;1. use self-balanced BST O(n log n). 2. Use dequeue keeping only useful elements O(n)
Tree: Check if a tree is a BST (2);1. recursive propagate min/max O(n), 2. check if in-order traversal is sorted O(n)
Tree: Serialize/Deserialize;Special case? BST, complete, full?. Inorder array with null marker
Tree: Inorder sucessor in BT with parent pointer;If right subtree of node is not NULL, successor in minimum of right subtree. Else then succ is one of the ancestors. Travel up using the parent pointer until you see a node which is left child of it’s parent. The parent of such a node is the succ. O(h)
Tree: Inorder sucessor in BST without parent pointer;Search from root O(h). Instead of traveling up with parent pointers: Travel down the tree, if a node’s data is greater than root’s data then go right side, otherwise go to left side.
Tree: k-th highest element of BST;reverse inorder traversal of BST. O(h + k)
SD: L1 cache reference; 1 ns
SD: L2 cache reference;10 ns       10x L1 cache
SD: Main memory reference;100 ns       100x L1 cache, 10x L2 cache
Array: Given infinite coins of value (V1, V2, … ,VN), find the minimum number of coins with sum S;DP(n, S)
Array: Continuous median;maintain 2 big balanced heaps
Array: Given an array of integers, every element appears twice except for one. Find that single one;XOR O(n)
String: Is a string with (), {}, [] balanced;stack with active items O(n)
SD: vertical scaling;add more power to a machine
SD: horizontal scaling;add more machines
SD: Master-slave replication;The master serves reads and writes, replicating writes to one or more slaves, which serve only reads. Slaves can also replicate to additional slaves in a tree-like fashion. If the master goes offline, the system can continue to operate in read-only mode until a slave is promoted to a master or a new master is provisioned.
SD: Master-master replication;Both masters serve reads and writes and coordinate with each other on writes. If either master goes down, the system can continue to operate with both reads and writes.
SD: Federation;(or functional partitioning) splits up databases by function. For example, instead of a single, monolithic database, you could have three databases: forums, users, and products
SD: Sharding;distributes data across different databases such that each database can only manage a subset of the data.
SD: Denormalization;attempts to improve read performance at the expense of some write performance. Redundant copies of the data are written in multiple tables to avoid expensive joins. 
SD: NoSQL; is a collection of data items represented in a key-value store, document-store, wide column store, or a graph database. Data is denormalized, and joins are generally done in the application code.
SD: NoSQL key-value store;Redis, memcached
SD: NoSQL document store;MongoDB, CouchDB, ElasticSearch
SD: NoSQL wide-column store;BigTable, HBase, Cassandra
SD: NoSQL graph database;neo4j, flockdb
